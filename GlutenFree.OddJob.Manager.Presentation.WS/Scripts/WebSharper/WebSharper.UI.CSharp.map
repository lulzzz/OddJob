{
"version": 3,
"sourceRoot": "Source",
"sources": ["WebSharper.UI.CSharp/Reactive.fs", "WebSharper.UI.CSharp/HTML.Client.fs", "WebSharper.UI.CSharp/Routing.fs"],
"sourcesContent": ["// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2018 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\nnamespace WebSharper.UI\n\nopen WebSharper\n\nopen System\nopen System.Threading.Tasks\nopen System.Runtime.CompilerServices\n\n[<Extension; JavaScript>]\ntype ViewExtensions =\n    [<Extension; Inline>]\n    static member Map(v, f: Func<'A, 'B>) = \n        View.Map (FSharpConvert.Fun f) v\n\n    [<Extension; Inline>]\n    static member MapAsync(v, f: Func<'A, Task<'B>>) =\n        v |> View.MapAsync (fun a -> Async.AwaitTask <| f.Invoke a)\n\n    [<Extension; Inline>]\n    static member Bind(v, f: Func<'A, View<'B>>) =\n        View.Bind (FSharpConvert.Fun f) v\n\n    [<Extension; Inline>]\n    static member MapCached(v, f: Func<'A, 'B>) =\n        View.MapCached (FSharpConvert.Fun f) v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v, f: Func<'A, 'B>) = View.MapSeqCached (FSharpConvert.Fun f) v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A, 'B when 'A : equality>\n        (v, f: Func<View<'A>, 'B>) = View.MapSeqCachedView (FSharpConvert.Fun f) v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A,'B,'K when 'K : equality>\n        (v, f: Func<'A, 'K>, g: Func<'A, 'B>) =\n        View.MapSeqCachedBy (FSharpConvert.Fun f) (FSharpConvert.Fun g) v\n\n    [<Extension; Inline>]\n    static member MapSeqCached<'A,'B,'K when 'K : equality>\n        (v, f: Func<'A, 'K>, g: Func<'K, View<'A>, 'B>) =\n        View.MapSeqCachedViewBy (FSharpConvert.Fun f) (FSharpConvert.Fun g) v\n\n    [<Extension; Inline>]\n    static member Sink(v, f: Func<'A, unit>) =\n        View.Sink (FSharpConvert.Fun f) v\n\n    [<Extension; Inline>]\n    static member Map2(va, vb, f: Func<'A, 'B, 'C>) =\n        View.Map2 (FSharpConvert.Fun f) va vb\n\n    [<Extension; Inline>]\n    static member MapAsync2(v1, v2, f: Func<'A, 'B, Task<'C>>) =\n        View.MapAsync2 (fun a b -> Async.AwaitTask <| f.Invoke(a, b)) v1 v2\n\n    [<Extension; Inline>]\n    static member Apply(vf: View<Func<'A, 'B>>, va) =\n        View.Apply (vf.Map (fun x -> FSharpConvert.Fun x)) va\n\n    [<Extension; Inline>]\n    static member Join(v) =\n        View.Join v\n\n    [<Extension; Inline>]\n    static member Sequence(s) =\n        View.Sequence s\n\n    [<Extension; Inline>]\n    static member SnapshotOn(vb, b, va) =\n        View.SnapshotOn b va vb\n\n    [<Extension>]\n    static member UpdateWhile(va, a, vb) =\n        View.UpdateWhile a vb va\n\n[<Extension; JavaScript; Sealed>]\ntype VarExtension =\n    [<Extension; Inline>]\n    static member Update(ref: Var<'A>, f: Func<'A, 'A>) =\n        ref.Update (FSharpConvert.Fun f)\n\n    [<Extension; Inline>]\n    static member Lens(ref: Var<'A>, get: Func<'A, 'B>, set: Func<'A, 'B, 'A>) =\n        Var.Lens ref (FSharpConvert.Fun get) (FSharpConvert.Fun set)\n\n[<Extension; JavaScript; Sealed>]\ntype VarExtensions =\n    \n    [<Extension; Inline>]\n    static member Update(var, f: Func<'A, 'A>) =\n        Var.Update var (FSharpConvert.Fun f)\n\n[<Extension; Sealed; JavaScript>]\ntype DocExtension =\n    [<Extension; Inline>]\n    static member Doc(v, f: Func<'T, Doc>) =\n        Client.Doc.BindView (FSharpConvert.Fun f) v\n\n    [<Extension; Inline>]\n    static member DocSeqCached<'T when 'T : equality>\n        (v: View<seq<'T>>, f: Func<'T, Doc>) =\n        Client.Doc.BindSeqCached (FSharpConvert.Fun f) v\n\n    [<Extension; Inline>]\n    static member DocSeqCached<'T,'K when 'K : equality>\n        (v: View<seq<'T>>, f: Func<'T,'K>, g: Func<'T, Doc>) =\n        Client.Doc.BindSeqCachedBy (FSharpConvert.Fun f) (FSharpConvert.Fun g) v\n\n    [<Extension; Inline>]\n    static member DocSeqCached<'T when 'T : equality>\n        (v: View<seq<'T>>, f: Func<View<'T>, Doc>) =\n        Client.Doc.BindSeqCachedView (FSharpConvert.Fun f) v\n\n    [<Extension>]\n    static member DocSeqCached<'T,'K when 'K : equality>\n        (v: View<seq<'T>>, f: Func<'T, 'K>, g: Func<'K, View<'T>, Doc>) =\n        Client.Doc.BindSeqCachedViewBy (FSharpConvert.Fun f) (FSharpConvert.Fun g) v\n\n    [<Extension>]\n    static member DocLens<'T,'K when 'K : equality>\n        (v: Var<list<'T>>, f: Func<'T, 'K>, g: Func<Var<'T>, Doc>) =\n        Client.DocExtensions.DocLens(v, FSharpConvert.Fun f, FSharpConvert.Fun g)\n\n    [<Extension>]\n    static member Doc<'T,'K when 'K : equality>\n        (model: ListModel<'K, 'T>, f: Func<'T, Doc>) =\n        Client.DocExtensions.Doc(model, FSharpConvert.Fun f)\n\n    [<Extension>]\n    static member Doc<'T,'K when 'K : equality>\n        (model: ListModel<'K, 'T>, f: Func<'K, View<'T>, Doc>) =\n        Client.DocExtensions.Doc(model, FSharpConvert.Fun f)\n\n    [<Extension>]\n    static member DocLens<'T, 'K when 'K : equality>\n        (model: ListModel<'K, 'T>, f: Func<'K, Var<'T>, Doc>) =\n        Client.DocExtensions.DocLens(model, FSharpConvert.Fun f)\n\n[<assembly:Extension>]\ndo ()\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2018 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\nnamespace WebSharper.UI.Client\n\n#nowarn \"44\" // HTML deprecated\n\nopen System\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\n\n[<AutoOpen>]\nmodule private Helpers =\n    [<JavaScript>]\n    let seqRefToListRef (l: Var<seq<'T>>) =\n        Var.Lens l (Seq.toList) (fun _ b -> Seq.ofList b)\n\n[<JavaScript>]\nmodule Html =\n\n    /// Embeds time-varying fragments.\n    [<Inline; CompiledName \"doc\">]\n    let EmbedView(v: View<#Doc>) =\n        Client.Doc.EmbedView v\n\n    /// Embeds time-varying fragments.\n    [<Inline; CompiledName \"doc\">]\n    let BindView(v: View<'T>, f: Func<'T, #Doc>) =\n        Client.Doc.BindView (FSharpConvert.Fun f) v\n\n    /// Creates a Doc using a given DOM element.\n    [<Inline; CompiledName \"doc\">]\n    let Static(e: Dom.Element) =\n        Client.Doc.Static e\n\n    /// Embeds an asynchronous Doc. The resulting Doc is empty until the Async returns.\n    [<Inline; CompiledName \"doc\">]\n    let Async(d: Async<#Doc>) =\n        Client.Doc.Async d\n\n    /// Creates a Doc by concatenating Docs.\n    [<Inline; CompiledName \"doc\"; Macro(typeof<Macros.DocConcatMixed>)>]\n    let ConcatMixed([<ParamArray>] docs: obj[]) =\n        Doc.ConcatMixed docs\n\n    /// Constructs a text node.\n    [<Inline; CompiledName \"text\"; Macro(typeof<Macros.TextView>)>]\n    let TextNode(v) =\n        Doc.TextNode v\n\n    /// Constructs a reactive text node.\n    [<Inline; CompiledName \"text\">]\n    let TextView(v) =\n        Client.Doc.TextView v\n\n    /// Input box.\n    [<Inline; CompiledName \"input\">]\n    let StringInput(var, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.Input attrs var\n\n    /// Input box with type=\"number\".\n    /// For validation to work properly in Internet Explorer 9 and older,\n    /// needs to be inside a <form> with Attr.ValidateForm.\n    [<Inline; CompiledName \"input\">]\n    let IntInput(var, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.IntInputUnchecked attrs var\n\n    // TODO checked int input\n\n    /// Input box with type=\"number\".\n    /// If the input box is blank, the value is set to 0.\n    /// If the input is not parseable as a float, the value is unchanged from its last valid value.\n    /// It is advised to use FloatInput instead for better user experience.\n    [<Inline; CompiledName \"input\">]\n    let FloatInput(var, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.FloatInputUnchecked attrs var\n\n    /// Input text area.\n    [<Inline; CompiledName \"textarea\">]\n    let TextAreaInput(var, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.InputArea attrs var\n\n    /// Password box.\n    [<Inline; CompiledName \"passwordBox\">]\n    let PasswordBox(var, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.PasswordBox attrs var\n\n    /// Submit button. Calls the callback function when the button is pressed.\n    [<Inline; CompiledName \"button\">]\n    let ButtonInput(caption, callback: Action, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.Button caption attrs (FSharpConvert.Fun callback)\n\n    /// Submit button. Takes a view of reactive components with which it is associated,\n    /// and a callback function of what to do with this view once the button is pressed.\n    [<Inline; CompiledName \"button\">]\n    let ButtonInputView(caption, view, callback: Action<'T>, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.ButtonView caption attrs view (FSharpConvert.Fun callback)\n\n    /// Hyperlink. Calls the callback function when the link is clicked.\n    [<Inline; CompiledName \"link\">]\n    let LinkInput(caption, cb: Action, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.Link caption attrs (FSharpConvert.Fun cb)\n\n    /// Hyperlink. Takes a view of reactive components with which it is associated,\n    /// and a callback function of what to do with this view once the link is clicked.\n    [<Inline; CompiledName \"link\">]\n    let LinkInputView(caption, view, callback: Action<'T>, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.LinkView caption attrs view (FSharpConvert.Fun callback)\n\n    /// Check Box.\n    [<Inline; CompiledName \"checkbox\">]\n    let CheckBox(var, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.CheckBox attrs var\n\n    /// Check Box which is part of a Group.\n    [<Inline; CompiledName \"checkbox\">]\n    let CheckBoxGroup(vl, l: Var<seq<'T>>, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.CheckBoxGroup attrs vl (seqRefToListRef l) \n\n    /// Select box.\n    [<Inline; CompiledName \"select\">]\n    let SelectInput(var: Var<'T>, options: seq<'T>, text: Func<'T, string>, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.Select attrs (FSharpConvert.Fun text) (Seq.toList options) var\n\n    /// Select box with time-varying option list.\n    [<Inline; CompiledName \"select\">]\n    let SelectInputDyn(var: Var<'T>, options: View<seq<'T>>, text: Func<'T, string>, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.SelectDyn attrs (FSharpConvert.Fun text) (View.Map Seq.toList options) var\n\n    /// Select box where the first option returns None.\n    [<Inline; CompiledName \"select\">]\n    let SelectInputOptional(var, options, noneText, text: Func<'T, string>, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.SelectOptional attrs noneText (FSharpConvert.Fun text) (Seq.toList options) var\n\n    /// Select box with time-varying option list where the first option returns None.\n    [<Inline; CompiledName \"select\">]\n    let SelectInputDynOptional(var, options: View<seq<'T>>, noneText, text: Func<'T, string>, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.SelectDynOptional attrs noneText (FSharpConvert.Fun text) (View.Map Seq.toList options) var\n\n    /// Radio button.\n    [<Inline; CompiledName \"radio\">]\n    let Radio(var, vl, [<ParamArray>] attrs: Attr[]) =\n        Client.Doc.Radio attrs vl var\n\n    /// Sets a basic DOM attribute, such as `id` to a text value.\n    [<Inline; CompiledName \"attrib\">]\n    let Attribute(name, value) = Attr.Create name value\n\n    /// Sets a basic DOM attribute, such as `id` to a text value.\n    [<Inline; CompiledName \"attrib\">]\n    let AttributeDyn(name, view) = Client.Attr.Dynamic name view\n\n    /// Sets a basic DOM attribute, such as `id` to a text value.\n    [<Inline; CompiledName \"attrib\">]\n    let AttributeDynPred(name, view, pred) = Client.Attr.DynamicPred name pred view\n\n    [<Inline; CompiledName \"attrib\">]\n    let AttrConcat ([<ParamArray>] attrs: Attr[]) = Attr.Concat attrs\n\n    /// Sets a style attribute, such as `background-color`.\n    [<Inline; CompiledName \"style\"; Macro(typeof<Macros.AttrStyle>)>]\n    let Style(name, value) = Client.Attr.Style name value\n\n    /// Dynamic variant of Style.\n    [<Inline; CompiledName \"style\">]\n    let StyleDyn(name, view: View<string>) = Client.Attr.DynamicStyle name view\n\n    /// Animated variant of Style.\n    [<Inline; CompiledName \"style\">]\n    let StyleAnim(name, tr, view, attr: Func<_,_>) = Client.Attr.AnimatedStyle name tr view (FSharpConvert.Fun attr)\n\n    /// Sets an event handler, for a given event such as `click`.\n    [<Inline; CompiledName \"handler\">]\n    let Handler(name, callback: Action<Dom.Element, Dom.Event>) = Client.Attr.Handler name (FSharpConvert.Fun callback)\n\n    /// Sets an event handler, for a given event such as `click`.\n    [<Inline; CompiledName \"handler\">]\n    let HandlerView(name, view: View<'T>, callback: Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView name view (FSharpConvert.Fun callback)\n\n    // {{ tag normal\n    /// Create an HTML element <a> with children nodes.\n    [<Inline; CompiledName \"a\"; Macro(typeof<Macros.ElementMixed>, \"a\")>]\n    let A ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"a\" ns\n    /// Create an HTML element <abbr> with children nodes.\n    [<Inline; CompiledName \"abbr\"; Macro(typeof<Macros.ElementMixed>, \"abbr\")>]\n    let Abbr ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"abbr\" ns\n    /// Create an HTML element <address> with children nodes.\n    [<Inline; CompiledName \"address\"; Macro(typeof<Macros.ElementMixed>, \"address\")>]\n    let Address ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"address\" ns\n    /// Create an HTML element <area> with children nodes.\n    [<Inline; CompiledName \"area\"; Macro(typeof<Macros.ElementMixed>, \"area\")>]\n    let Area ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"area\" ns\n    /// Create an HTML element <article> with children nodes.\n    [<Inline; CompiledName \"article\"; Macro(typeof<Macros.ElementMixed>, \"article\")>]\n    let Article ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"article\" ns\n    /// Create an HTML element <aside> with children nodes.\n    [<Inline; CompiledName \"aside\"; Macro(typeof<Macros.ElementMixed>, \"aside\")>]\n    let Aside ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"aside\" ns\n    /// Create an HTML element <audio> with children nodes.\n    [<Inline; CompiledName \"audio\"; Macro(typeof<Macros.ElementMixed>, \"audio\")>]\n    let Audio ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"audio\" ns\n    /// Create an HTML element <b> with children nodes.\n    [<Inline; CompiledName \"b\"; Macro(typeof<Macros.ElementMixed>, \"b\")>]\n    let B ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"b\" ns\n    /// Create an HTML element <base> with children nodes.\n    [<Inline; CompiledName \"base\"; Macro(typeof<Macros.ElementMixed>, \"base\")>]\n    let Base ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"base\" ns\n    /// Create an HTML element <bdi> with children nodes.\n    [<Inline; CompiledName \"bdi\"; Macro(typeof<Macros.ElementMixed>, \"bdi\")>]\n    let BDI ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"bdi\" ns\n    /// Create an HTML element <bdo> with children nodes.\n    [<Inline; CompiledName \"bdo\"; Macro(typeof<Macros.ElementMixed>, \"bdo\")>]\n    let BDO ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"bdo\" ns\n    /// Create an HTML element <blockquote> with children nodes.\n    [<Inline; CompiledName \"blockquote\"; Macro(typeof<Macros.ElementMixed>, \"blockquote\")>]\n    let BlockQuote ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"blockquote\" ns\n    /// Create an HTML element <body> with children nodes.\n    [<Inline; CompiledName \"body\"; Macro(typeof<Macros.ElementMixed>, \"body\")>]\n    let Body ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"body\" ns\n    /// Create an HTML element <br> with children nodes.\n    [<Inline; CompiledName \"br\"; Macro(typeof<Macros.ElementMixed>, \"br\")>]\n    let Br ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"br\" ns\n    /// Create an HTML element <button> with children nodes.\n    [<Inline; CompiledName \"button\"; Macro(typeof<Macros.ElementMixed>, \"button\")>]\n    let Button ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"button\" ns\n    /// Create an HTML element <canvas> with children nodes.\n    [<Inline; CompiledName \"canvas\"; Macro(typeof<Macros.ElementMixed>, \"canvas\")>]\n    let Canvas ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"canvas\" ns\n    /// Create an HTML element <caption> with children nodes.\n    [<Inline; CompiledName \"caption\"; Macro(typeof<Macros.ElementMixed>, \"caption\")>]\n    let Caption ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"caption\" ns\n    /// Create an HTML element <cite> with children nodes.\n    [<Inline; CompiledName \"cite\"; Macro(typeof<Macros.ElementMixed>, \"cite\")>]\n    let Cite ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"cite\" ns\n    /// Create an HTML element <code> with children nodes.\n    [<Inline; CompiledName \"code\"; Macro(typeof<Macros.ElementMixed>, \"code\")>]\n    let Code ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"code\" ns\n    /// Create an HTML element <col> with children nodes.\n    [<Inline; CompiledName \"col\"; Macro(typeof<Macros.ElementMixed>, \"col\")>]\n    let Col ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"col\" ns\n    /// Create an HTML element <colgroup> with children nodes.\n    [<Inline; CompiledName \"colgroup\"; Macro(typeof<Macros.ElementMixed>, \"colgroup\")>]\n    let ColGroup ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"colgroup\" ns\n    /// Create an HTML element <command> with children nodes.\n    [<Inline; CompiledName \"command\"; Macro(typeof<Macros.ElementMixed>, \"command\")>]\n    let Command ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"command\" ns\n    /// Create an HTML element <datalist> with children nodes.\n    [<Inline; CompiledName \"datalist\"; Macro(typeof<Macros.ElementMixed>, \"datalist\")>]\n    let DataList ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"datalist\" ns\n    /// Create an HTML element <dd> with children nodes.\n    [<Inline; CompiledName \"dd\"; Macro(typeof<Macros.ElementMixed>, \"dd\")>]\n    let DD ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"dd\" ns\n    /// Create an HTML element <del> with children nodes.\n    [<Inline; CompiledName \"del\"; Macro(typeof<Macros.ElementMixed>, \"del\")>]\n    let Del ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"del\" ns\n    /// Create an HTML element <details> with children nodes.\n    [<Inline; CompiledName \"details\"; Macro(typeof<Macros.ElementMixed>, \"details\")>]\n    let Details ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"details\" ns\n    /// Create an HTML element <dfn> with children nodes.\n    [<Inline; CompiledName \"dfn\"; Macro(typeof<Macros.ElementMixed>, \"dfn\")>]\n    let Dfn ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"dfn\" ns\n    /// Create an HTML element <div> with children nodes.\n    [<Inline; CompiledName \"div\"; Macro(typeof<Macros.ElementMixed>, \"div\")>]\n    let Div ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"div\" ns\n    /// Create an HTML element <dl> with children nodes.\n    [<Inline; CompiledName \"dl\"; Macro(typeof<Macros.ElementMixed>, \"dl\")>]\n    let DL ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"dl\" ns\n    /// Create an HTML element <dt> with children nodes.\n    [<Inline; CompiledName \"dt\"; Macro(typeof<Macros.ElementMixed>, \"dt\")>]\n    let DT ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"dt\" ns\n    /// Create an HTML element <em> with children nodes.\n    [<Inline; CompiledName \"em\"; Macro(typeof<Macros.ElementMixed>, \"em\")>]\n    let Em ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"em\" ns\n    /// Create an HTML element <embed> with children nodes.\n    [<Inline; CompiledName \"embed\"; Macro(typeof<Macros.ElementMixed>, \"embed\")>]\n    let Embed ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"embed\" ns\n    /// Create an HTML element <fieldset> with children nodes.\n    [<Inline; CompiledName \"fieldset\"; Macro(typeof<Macros.ElementMixed>, \"fieldset\")>]\n    let FieldSet ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"fieldset\" ns\n    /// Create an HTML element <figcaption> with children nodes.\n    [<Inline; CompiledName \"figcaption\"; Macro(typeof<Macros.ElementMixed>, \"figcaption\")>]\n    let FigCaption ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"figcaption\" ns\n    /// Create an HTML element <figure> with children nodes.\n    [<Inline; CompiledName \"figure\"; Macro(typeof<Macros.ElementMixed>, \"figure\")>]\n    let Figure ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"figure\" ns\n    /// Create an HTML element <footer> with children nodes.\n    [<Inline; CompiledName \"footer\"; Macro(typeof<Macros.ElementMixed>, \"footer\")>]\n    let Footer ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"footer\" ns\n    /// Create an HTML element <form> with children nodes.\n    [<Inline; CompiledName \"form\"; Macro(typeof<Macros.ElementMixed>, \"form\")>]\n    let Form ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"form\" ns\n    /// Create an HTML element <h1> with children nodes.\n    [<Inline; CompiledName \"h1\"; Macro(typeof<Macros.ElementMixed>, \"h1\")>]\n    let H1 ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"h1\" ns\n    /// Create an HTML element <h2> with children nodes.\n    [<Inline; CompiledName \"h2\"; Macro(typeof<Macros.ElementMixed>, \"h2\")>]\n    let H2 ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"h2\" ns\n    /// Create an HTML element <h3> with children nodes.\n    [<Inline; CompiledName \"h3\"; Macro(typeof<Macros.ElementMixed>, \"h3\")>]\n    let H3 ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"h3\" ns\n    /// Create an HTML element <h4> with children nodes.\n    [<Inline; CompiledName \"h4\"; Macro(typeof<Macros.ElementMixed>, \"h4\")>]\n    let H4 ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"h4\" ns\n    /// Create an HTML element <h5> with children nodes.\n    [<Inline; CompiledName \"h5\"; Macro(typeof<Macros.ElementMixed>, \"h5\")>]\n    let H5 ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"h5\" ns\n    /// Create an HTML element <h6> with children nodes.\n    [<Inline; CompiledName \"h6\"; Macro(typeof<Macros.ElementMixed>, \"h6\")>]\n    let H6 ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"h6\" ns\n    /// Create an HTML element <head> with children nodes.\n    [<Inline; CompiledName \"head\"; Macro(typeof<Macros.ElementMixed>, \"head\")>]\n    let Head ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"head\" ns\n    /// Create an HTML element <header> with children nodes.\n    [<Inline; CompiledName \"header\"; Macro(typeof<Macros.ElementMixed>, \"header\")>]\n    let Header ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"header\" ns\n    /// Create an HTML element <hgroup> with children nodes.\n    [<Inline; CompiledName \"hgroup\"; Macro(typeof<Macros.ElementMixed>, \"hgroup\")>]\n    let HGroup ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"hgroup\" ns\n    /// Create an HTML element <hr> with children nodes.\n    [<Inline; CompiledName \"hr\"; Macro(typeof<Macros.ElementMixed>, \"hr\")>]\n    let HR ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"hr\" ns\n    /// Create an HTML element <html> with children nodes.\n    [<Inline; CompiledName \"html\"; Macro(typeof<Macros.ElementMixed>, \"html\")>]\n    let HTML ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"html\" ns\n    /// Create an HTML element <i> with children nodes.\n    [<Inline; CompiledName \"i\"; Macro(typeof<Macros.ElementMixed>, \"i\")>]\n    let I ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"i\" ns\n    /// Create an HTML element <iframe> with children nodes.\n    [<Inline; CompiledName \"iframe\"; Macro(typeof<Macros.ElementMixed>, \"iframe\")>]\n    let IFrame ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"iframe\" ns\n    /// Create an HTML element <img> with children nodes.\n    [<Inline; CompiledName \"img\"; Macro(typeof<Macros.ElementMixed>, \"img\")>]\n    let Img ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"img\" ns\n    /// Create an HTML element <input> with children nodes.\n    [<Inline; CompiledName \"input\"; Macro(typeof<Macros.ElementMixed>, \"input\")>]\n    let Input ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"input\" ns\n    /// Create an HTML element <ins> with children nodes.\n    [<Inline; CompiledName \"ins\"; Macro(typeof<Macros.ElementMixed>, \"ins\")>]\n    let Ins ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"ins\" ns\n    /// Create an HTML element <kbd> with children nodes.\n    [<Inline; CompiledName \"kbd\"; Macro(typeof<Macros.ElementMixed>, \"kbd\")>]\n    let Kbd ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"kbd\" ns\n    /// Create an HTML element <keygen> with children nodes.\n    [<Inline; CompiledName \"keygen\"; Macro(typeof<Macros.ElementMixed>, \"keygen\")>]\n    let KeyGen ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"keygen\" ns\n    /// Create an HTML element <label> with children nodes.\n    [<Inline; CompiledName \"label\"; Macro(typeof<Macros.ElementMixed>, \"label\")>]\n    let Label ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"label\" ns\n    /// Create an HTML element <legend> with children nodes.\n    [<Inline; CompiledName \"legend\"; Macro(typeof<Macros.ElementMixed>, \"legend\")>]\n    let Legend ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"legend\" ns\n    /// Create an HTML element <li> with children nodes.\n    [<Inline; CompiledName \"li\"; Macro(typeof<Macros.ElementMixed>, \"li\")>]\n    let LI ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"li\" ns\n    /// Create an HTML element <link> with children nodes.\n    [<Inline; CompiledName \"link\"; Macro(typeof<Macros.ElementMixed>, \"link\")>]\n    let Link ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"link\" ns\n    /// Create an HTML element <mark> with children nodes.\n    [<Inline; CompiledName \"mark\"; Macro(typeof<Macros.ElementMixed>, \"mark\")>]\n    let Mark ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"mark\" ns\n    /// Create an HTML element <meta> with children nodes.\n    [<Inline; CompiledName \"meta\"; Macro(typeof<Macros.ElementMixed>, \"meta\")>]\n    let Meta ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"meta\" ns\n    /// Create an HTML element <meter> with children nodes.\n    [<Inline; CompiledName \"meter\"; Macro(typeof<Macros.ElementMixed>, \"meter\")>]\n    let Meter ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"meter\" ns\n    /// Create an HTML element <nav> with children nodes.\n    [<Inline; CompiledName \"nav\"; Macro(typeof<Macros.ElementMixed>, \"nav\")>]\n    let Nav ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"nav\" ns\n    /// Create an HTML element <noframes> with children nodes.\n    [<Inline; CompiledName \"noframes\"; Macro(typeof<Macros.ElementMixed>, \"noframes\")>]\n    let NoFrames ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"noframes\" ns\n    /// Create an HTML element <noscript> with children nodes.\n    [<Inline; CompiledName \"noscript\"; Macro(typeof<Macros.ElementMixed>, \"noscript\")>]\n    let NoScript ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"noscript\" ns\n    /// Create an HTML element <ol> with children nodes.\n    [<Inline; CompiledName \"ol\"; Macro(typeof<Macros.ElementMixed>, \"ol\")>]\n    let OL ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"ol\" ns\n    /// Create an HTML element <optgroup> with children nodes.\n    [<Inline; CompiledName \"optgroup\"; Macro(typeof<Macros.ElementMixed>, \"optgroup\")>]\n    let OptGroup ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"optgroup\" ns\n    /// Create an HTML element <output> with children nodes.\n    [<Inline; CompiledName \"output\"; Macro(typeof<Macros.ElementMixed>, \"output\")>]\n    let Output ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"output\" ns\n    /// Create an HTML element <p> with children nodes.\n    [<Inline; CompiledName \"p\"; Macro(typeof<Macros.ElementMixed>, \"p\")>]\n    let P ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"p\" ns\n    /// Create an HTML element <param> with children nodes.\n    [<Inline; CompiledName \"param\"; Macro(typeof<Macros.ElementMixed>, \"param\")>]\n    let Param ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"param\" ns\n    /// Create an HTML element <picture> with children nodes.\n    [<Inline; CompiledName \"picture\"; Macro(typeof<Macros.ElementMixed>, \"picture\")>]\n    let Picture ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"picture\" ns\n    /// Create an HTML element <pre> with children nodes.\n    [<Inline; CompiledName \"pre\"; Macro(typeof<Macros.ElementMixed>, \"pre\")>]\n    let Pre ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"pre\" ns\n    /// Create an HTML element <progress> with children nodes.\n    [<Inline; CompiledName \"progress\"; Macro(typeof<Macros.ElementMixed>, \"progress\")>]\n    let Progress ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"progress\" ns\n    /// Create an HTML element <q> with children nodes.\n    [<Inline; CompiledName \"q\"; Macro(typeof<Macros.ElementMixed>, \"q\")>]\n    let Q ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"q\" ns\n    /// Create an HTML element <rp> with children nodes.\n    [<Inline; CompiledName \"rp\"; Macro(typeof<Macros.ElementMixed>, \"rp\")>]\n    let RP ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"rp\" ns\n    /// Create an HTML element <rt> with children nodes.\n    [<Inline; CompiledName \"rt\"; Macro(typeof<Macros.ElementMixed>, \"rt\")>]\n    let RT ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"rt\" ns\n    /// Create an HTML element <rtc> with children nodes.\n    [<Inline; CompiledName \"rtc\"; Macro(typeof<Macros.ElementMixed>, \"rtc\")>]\n    let RTC ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"rtc\" ns\n    /// Create an HTML element <ruby> with children nodes.\n    [<Inline; CompiledName \"ruby\"; Macro(typeof<Macros.ElementMixed>, \"ruby\")>]\n    let Ruby ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"ruby\" ns\n    /// Create an HTML element <samp> with children nodes.\n    [<Inline; CompiledName \"samp\"; Macro(typeof<Macros.ElementMixed>, \"samp\")>]\n    let Samp ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"samp\" ns\n    /// Create an HTML element <script> with children nodes.\n    [<Inline; CompiledName \"script\"; Macro(typeof<Macros.ElementMixed>, \"script\")>]\n    let Script ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"script\" ns\n    /// Create an HTML element <section> with children nodes.\n    [<Inline; CompiledName \"section\"; Macro(typeof<Macros.ElementMixed>, \"section\")>]\n    let Section ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"section\" ns\n    /// Create an HTML element <select> with children nodes.\n    [<Inline; CompiledName \"select\"; Macro(typeof<Macros.ElementMixed>, \"select\")>]\n    let Select ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"select\" ns\n    /// Create an HTML element <shadow> with children nodes.\n    [<Inline; CompiledName \"shadow\"; Macro(typeof<Macros.ElementMixed>, \"shadow\")>]\n    let Shadow ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"shadow\" ns\n    /// Create an HTML element <small> with children nodes.\n    [<Inline; CompiledName \"small\"; Macro(typeof<Macros.ElementMixed>, \"small\")>]\n    let Small ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"small\" ns\n    /// Create an HTML element <source> with children nodes.\n    [<Inline; CompiledName \"source\"; Macro(typeof<Macros.ElementMixed>, \"source\")>]\n    let Source ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"source\" ns\n    /// Create an HTML element <span> with children nodes.\n    [<Inline; CompiledName \"span\"; Macro(typeof<Macros.ElementMixed>, \"span\")>]\n    let Span ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"span\" ns\n    /// Create an HTML element <strong> with children nodes.\n    [<Inline; CompiledName \"strong\"; Macro(typeof<Macros.ElementMixed>, \"strong\")>]\n    let Strong ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"strong\" ns\n    /// Create an HTML element <sub> with children nodes.\n    [<Inline; CompiledName \"sub\"; Macro(typeof<Macros.ElementMixed>, \"sub\")>]\n    let Sub ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"sub\" ns\n    /// Create an HTML element <summary> with children nodes.\n    [<Inline; CompiledName \"summary\"; Macro(typeof<Macros.ElementMixed>, \"summary\")>]\n    let Summary ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"summary\" ns\n    /// Create an HTML element <sup> with children nodes.\n    [<Inline; CompiledName \"sup\"; Macro(typeof<Macros.ElementMixed>, \"sup\")>]\n    let Sup ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"sup\" ns\n    /// Create an HTML element <table> with children nodes.\n    [<Inline; CompiledName \"table\"; Macro(typeof<Macros.ElementMixed>, \"table\")>]\n    let Table ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"table\" ns\n    /// Create an HTML element <tbody> with children nodes.\n    [<Inline; CompiledName \"tbody\"; Macro(typeof<Macros.ElementMixed>, \"tbody\")>]\n    let TBody ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"tbody\" ns\n    /// Create an HTML element <td> with children nodes.\n    [<Inline; CompiledName \"td\"; Macro(typeof<Macros.ElementMixed>, \"td\")>]\n    let TD ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"td\" ns\n    /// Create an HTML element <textarea> with children nodes.\n    [<Inline; CompiledName \"textarea\"; Macro(typeof<Macros.ElementMixed>, \"textarea\")>]\n    let TextArea ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"textarea\" ns\n    /// Create an HTML element <tfoot> with children nodes.\n    [<Inline; CompiledName \"tfoot\"; Macro(typeof<Macros.ElementMixed>, \"tfoot\")>]\n    let TFoot ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"tfoot\" ns\n    /// Create an HTML element <th> with children nodes.\n    [<Inline; CompiledName \"th\"; Macro(typeof<Macros.ElementMixed>, \"th\")>]\n    let TH ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"th\" ns\n    /// Create an HTML element <thead> with children nodes.\n    [<Inline; CompiledName \"thead\"; Macro(typeof<Macros.ElementMixed>, \"thead\")>]\n    let THead ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"thead\" ns\n    /// Create an HTML element <time> with children nodes.\n    [<Inline; CompiledName \"time\"; Macro(typeof<Macros.ElementMixed>, \"time\")>]\n    let Time ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"time\" ns\n    /// Create an HTML element <tr> with children nodes.\n    [<Inline; CompiledName \"tr\"; Macro(typeof<Macros.ElementMixed>, \"tr\")>]\n    let TR ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"tr\" ns\n    /// Create an HTML element <track> with children nodes.\n    [<Inline; CompiledName \"track\"; Macro(typeof<Macros.ElementMixed>, \"track\")>]\n    let Track ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"track\" ns\n    /// Create an HTML element <ul> with children nodes.\n    [<Inline; CompiledName \"ul\"; Macro(typeof<Macros.ElementMixed>, \"ul\")>]\n    let UL ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"ul\" ns\n    /// Create an HTML element <video> with children nodes.\n    [<Inline; CompiledName \"video\"; Macro(typeof<Macros.ElementMixed>, \"video\")>]\n    let Video ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"video\" ns\n    /// Create an HTML element <wbr> with children nodes.\n    [<Inline; CompiledName \"wbr\"; Macro(typeof<Macros.ElementMixed>, \"wbr\")>]\n    let WBR ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"wbr\" ns\n    // }}\n\n    /// Additional and deprecated HTML5 element functions.\n    module Tags =\n\n        // {{ tag colliding deprecated\n        /// Create an HTML element <acronym> with children nodes.\n        [<Inline; CompiledName \"acronym\"; Macro(typeof<Macros.ElementMixed>, \"acronym\")>]\n        let Acronym ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"acronym\" ns\n        /// Create an HTML element <applet> with children nodes.\n        [<Inline; CompiledName \"applet\"; Macro(typeof<Macros.ElementMixed>, \"applet\")>]\n        let Applet ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"applet\" ns\n        /// Create an HTML element <basefont> with children nodes.\n        [<Inline; CompiledName \"basefont\"; Macro(typeof<Macros.ElementMixed>, \"basefont\")>]\n        let BaseFont ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"basefont\" ns\n        /// Create an HTML element <big> with children nodes.\n        [<Inline; CompiledName \"big\"; Macro(typeof<Macros.ElementMixed>, \"big\")>]\n        let Big ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"big\" ns\n        /// Create an HTML element <center> with children nodes.\n        [<Inline; CompiledName \"center\"; Macro(typeof<Macros.ElementMixed>, \"center\")>]\n        let Center ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"center\" ns\n        /// Create an HTML element <content> with children nodes.\n        [<Inline; CompiledName \"content\"; Macro(typeof<Macros.ElementMixed>, \"content\")>]\n        let Content ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"content\" ns\n        /// Create an HTML element <data> with children nodes.\n        [<Inline; CompiledName \"data\"; Macro(typeof<Macros.ElementMixed>, \"data\")>]\n        let Data ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"data\" ns\n        /// Create an HTML element <dir> with children nodes.\n        [<Inline; CompiledName \"dir\"; Macro(typeof<Macros.ElementMixed>, \"dir\")>]\n        let Dir ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"dir\" ns\n        /// Create an HTML element <font> with children nodes.\n        [<Inline; CompiledName \"font\"; Macro(typeof<Macros.ElementMixed>, \"font\")>]\n        let Font ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"font\" ns\n        /// Create an HTML element <frame> with children nodes.\n        [<Inline; CompiledName \"frame\"; Macro(typeof<Macros.ElementMixed>, \"frame\")>]\n        let Frame ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"frame\" ns\n        /// Create an HTML element <frameset> with children nodes.\n        [<Inline; CompiledName \"frameset\"; Macro(typeof<Macros.ElementMixed>, \"frameset\")>]\n        let FrameSet ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"frameset\" ns\n        /// Create an HTML element <isindex> with children nodes.\n        [<Inline; CompiledName \"isindex\"; Macro(typeof<Macros.ElementMixed>, \"isindex\")>]\n        let IsIndex ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"isindex\" ns\n        /// Create an HTML element <main> with children nodes.\n        [<Inline; CompiledName \"main\"; Macro(typeof<Macros.ElementMixed>, \"main\")>]\n        let Main ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"main\" ns\n        /// Create an HTML element <map> with children nodes.\n        [<Inline; CompiledName \"map\"; Macro(typeof<Macros.ElementMixed>, \"map\")>]\n        let Map ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"map\" ns\n        /// Create an HTML element <menu> with children nodes.\n        [<Inline; CompiledName \"menu\"; Macro(typeof<Macros.ElementMixed>, \"menu\")>]\n        let Menu ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"menu\" ns\n        /// Create an HTML element <menuitem> with children nodes.\n        [<Inline; CompiledName \"menuitem\"; Macro(typeof<Macros.ElementMixed>, \"menuitem\")>]\n        let MenuItem ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"menuitem\" ns\n        /// Create an HTML element <object> with children nodes.\n        [<Inline; CompiledName \"object\"; Macro(typeof<Macros.ElementMixed>, \"object\")>]\n        let Object ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"object\" ns\n        /// Create an HTML element <option> with children nodes.\n        [<Inline; CompiledName \"option\"; Macro(typeof<Macros.ElementMixed>, \"option\")>]\n        let Option ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"option\" ns\n        /// Create an HTML element <s> with children nodes.\n        [<Inline; CompiledName \"s\"; Macro(typeof<Macros.ElementMixed>, \"s\")>]\n        let S ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"s\" ns\n        /// Create an HTML element <strike> with children nodes.\n        [<Inline; CompiledName \"strike\"; Macro(typeof<Macros.ElementMixed>, \"strike\")>]\n        let Strike ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"strike\" ns\n        /// Create an HTML element <style> with children nodes.\n        [<Inline; CompiledName \"style\"; Macro(typeof<Macros.ElementMixed>, \"style\")>]\n        let Style ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"style\" ns\n        /// Create an HTML element <template> with children nodes.\n        [<Inline; CompiledName \"template\"; Macro(typeof<Macros.ElementMixed>, \"template\")>]\n        let Template ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"template\" ns\n        /// Create an HTML element <title> with children nodes.\n        [<Inline; CompiledName \"title\"; Macro(typeof<Macros.ElementMixed>, \"title\")>]\n        let Title ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"title\" ns\n        /// Create an HTML element <tt> with children nodes.\n        [<Inline; CompiledName \"tt\"; Macro(typeof<Macros.ElementMixed>, \"tt\")>]\n        let TT ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"tt\" ns\n        /// Create an HTML element <u> with children nodes.\n        [<Inline; CompiledName \"u\"; Macro(typeof<Macros.ElementMixed>, \"u\")>]\n        let U ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"u\" ns\n        /// Create an HTML element <var> with children nodes.\n        [<Inline; CompiledName \"var\"; Macro(typeof<Macros.ElementMixed>, \"var\")>]\n        let Var ([<ParamArray>] ns : obj[]) = Doc.ElementMixed \"var\" ns\n        // }}\n\n    /// SVG elements.\n    module SvgElements =\n\n        // {{ svgtag normal\n        /// Create an SVG element <a> with children nodes.\n        [<Inline; CompiledName \"a\"; Macro(typeof<Macros.ElementMixed>, \"a\")>]\n        let A ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"a\" ns\n        /// Create an SVG element <altglyph> with children nodes.\n        [<Inline; CompiledName \"altglyph\"; Macro(typeof<Macros.ElementMixed>, \"altglyph\")>]\n        let AltGlyph ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"altglyph\" ns\n        /// Create an SVG element <altglyphdef> with children nodes.\n        [<Inline; CompiledName \"altglyphdef\"; Macro(typeof<Macros.ElementMixed>, \"altglyphdef\")>]\n        let AltGlyphDef ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"altglyphdef\" ns\n        /// Create an SVG element <altglyphitem> with children nodes.\n        [<Inline; CompiledName \"altglyphitem\"; Macro(typeof<Macros.ElementMixed>, \"altglyphitem\")>]\n        let AltGlyphItem ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"altglyphitem\" ns\n        /// Create an SVG element <animate> with children nodes.\n        [<Inline; CompiledName \"animate\"; Macro(typeof<Macros.ElementMixed>, \"animate\")>]\n        let Animate ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"animate\" ns\n        /// Create an SVG element <animatecolor> with children nodes.\n        [<Inline; CompiledName \"animatecolor\"; Macro(typeof<Macros.ElementMixed>, \"animatecolor\")>]\n        let AnimateColor ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"animatecolor\" ns\n        /// Create an SVG element <animatemotion> with children nodes.\n        [<Inline; CompiledName \"animatemotion\"; Macro(typeof<Macros.ElementMixed>, \"animatemotion\")>]\n        let AnimateMotion ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"animatemotion\" ns\n        /// Create an SVG element <animatetransform> with children nodes.\n        [<Inline; CompiledName \"animatetransform\"; Macro(typeof<Macros.ElementMixed>, \"animatetransform\")>]\n        let AnimateTransform ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"animatetransform\" ns\n        /// Create an SVG element <circle> with children nodes.\n        [<Inline; CompiledName \"circle\"; Macro(typeof<Macros.ElementMixed>, \"circle\")>]\n        let Circle ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"circle\" ns\n        /// Create an SVG element <clippath> with children nodes.\n        [<Inline; CompiledName \"clippath\"; Macro(typeof<Macros.ElementMixed>, \"clippath\")>]\n        let ClipPath ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"clippath\" ns\n        /// Create an SVG element <color-profile> with children nodes.\n        [<Inline; CompiledName \"colorProfile\"; Macro(typeof<Macros.ElementMixed>, \"color-profile\")>]\n        let ColorProfile ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"color-profile\" ns\n        /// Create an SVG element <cursor> with children nodes.\n        [<Inline; CompiledName \"cursor\"; Macro(typeof<Macros.ElementMixed>, \"cursor\")>]\n        let Cursor ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"cursor\" ns\n        /// Create an SVG element <defs> with children nodes.\n        [<Inline; CompiledName \"defs\"; Macro(typeof<Macros.ElementMixed>, \"defs\")>]\n        let Defs ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"defs\" ns\n        /// Create an SVG element <desc> with children nodes.\n        [<Inline; CompiledName \"desc\"; Macro(typeof<Macros.ElementMixed>, \"desc\")>]\n        let Desc ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"desc\" ns\n        /// Create an SVG element <ellipse> with children nodes.\n        [<Inline; CompiledName \"ellipse\"; Macro(typeof<Macros.ElementMixed>, \"ellipse\")>]\n        let Ellipse ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"ellipse\" ns\n        /// Create an SVG element <feblend> with children nodes.\n        [<Inline; CompiledName \"feblend\"; Macro(typeof<Macros.ElementMixed>, \"feblend\")>]\n        let FeBlend ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"feblend\" ns\n        /// Create an SVG element <fecolormatrix> with children nodes.\n        [<Inline; CompiledName \"fecolormatrix\"; Macro(typeof<Macros.ElementMixed>, \"fecolormatrix\")>]\n        let FeColorMatrix ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fecolormatrix\" ns\n        /// Create an SVG element <fecomponenttransfer> with children nodes.\n        [<Inline; CompiledName \"fecomponenttransfer\"; Macro(typeof<Macros.ElementMixed>, \"fecomponenttransfer\")>]\n        let FeComponentTransfer ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fecomponenttransfer\" ns\n        /// Create an SVG element <fecomposite> with children nodes.\n        [<Inline; CompiledName \"fecomposite\"; Macro(typeof<Macros.ElementMixed>, \"fecomposite\")>]\n        let FeComposite ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fecomposite\" ns\n        /// Create an SVG element <feconvolvematrix> with children nodes.\n        [<Inline; CompiledName \"feconvolvematrix\"; Macro(typeof<Macros.ElementMixed>, \"feconvolvematrix\")>]\n        let FeConvolveMatrix ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"feconvolvematrix\" ns\n        /// Create an SVG element <fediffuselighting> with children nodes.\n        [<Inline; CompiledName \"fediffuselighting\"; Macro(typeof<Macros.ElementMixed>, \"fediffuselighting\")>]\n        let FeDiffuseLighting ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fediffuselighting\" ns\n        /// Create an SVG element <fedisplacementmap> with children nodes.\n        [<Inline; CompiledName \"fedisplacementmap\"; Macro(typeof<Macros.ElementMixed>, \"fedisplacementmap\")>]\n        let FeDisplacementMap ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fedisplacementmap\" ns\n        /// Create an SVG element <fedistantlight> with children nodes.\n        [<Inline; CompiledName \"fedistantlight\"; Macro(typeof<Macros.ElementMixed>, \"fedistantlight\")>]\n        let FeDistantLight ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fedistantlight\" ns\n        /// Create an SVG element <feflood> with children nodes.\n        [<Inline; CompiledName \"feflood\"; Macro(typeof<Macros.ElementMixed>, \"feflood\")>]\n        let FeFlood ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"feflood\" ns\n        /// Create an SVG element <fefunca> with children nodes.\n        [<Inline; CompiledName \"fefunca\"; Macro(typeof<Macros.ElementMixed>, \"fefunca\")>]\n        let FeFuncA ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fefunca\" ns\n        /// Create an SVG element <fefuncb> with children nodes.\n        [<Inline; CompiledName \"fefuncb\"; Macro(typeof<Macros.ElementMixed>, \"fefuncb\")>]\n        let FeFuncB ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fefuncb\" ns\n        /// Create an SVG element <fefuncg> with children nodes.\n        [<Inline; CompiledName \"fefuncg\"; Macro(typeof<Macros.ElementMixed>, \"fefuncg\")>]\n        let FeFuncG ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fefuncg\" ns\n        /// Create an SVG element <fefuncr> with children nodes.\n        [<Inline; CompiledName \"fefuncr\"; Macro(typeof<Macros.ElementMixed>, \"fefuncr\")>]\n        let FeFuncR ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fefuncr\" ns\n        /// Create an SVG element <fegaussianblur> with children nodes.\n        [<Inline; CompiledName \"fegaussianblur\"; Macro(typeof<Macros.ElementMixed>, \"fegaussianblur\")>]\n        let FeGaussianBlur ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fegaussianblur\" ns\n        /// Create an SVG element <feimage> with children nodes.\n        [<Inline; CompiledName \"feimage\"; Macro(typeof<Macros.ElementMixed>, \"feimage\")>]\n        let FeImage ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"feimage\" ns\n        /// Create an SVG element <femerge> with children nodes.\n        [<Inline; CompiledName \"femerge\"; Macro(typeof<Macros.ElementMixed>, \"femerge\")>]\n        let FeMerge ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"femerge\" ns\n        /// Create an SVG element <femergenode> with children nodes.\n        [<Inline; CompiledName \"femergenode\"; Macro(typeof<Macros.ElementMixed>, \"femergenode\")>]\n        let FeMergeNode ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"femergenode\" ns\n        /// Create an SVG element <femorphology> with children nodes.\n        [<Inline; CompiledName \"femorphology\"; Macro(typeof<Macros.ElementMixed>, \"femorphology\")>]\n        let FeMorphology ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"femorphology\" ns\n        /// Create an SVG element <feoffset> with children nodes.\n        [<Inline; CompiledName \"feoffset\"; Macro(typeof<Macros.ElementMixed>, \"feoffset\")>]\n        let FeOffset ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"feoffset\" ns\n        /// Create an SVG element <fepointlight> with children nodes.\n        [<Inline; CompiledName \"fepointlight\"; Macro(typeof<Macros.ElementMixed>, \"fepointlight\")>]\n        let FePointLight ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fepointlight\" ns\n        /// Create an SVG element <fespecularlighting> with children nodes.\n        [<Inline; CompiledName \"fespecularlighting\"; Macro(typeof<Macros.ElementMixed>, \"fespecularlighting\")>]\n        let FeSpecularLighting ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fespecularlighting\" ns\n        /// Create an SVG element <fespotlight> with children nodes.\n        [<Inline; CompiledName \"fespotlight\"; Macro(typeof<Macros.ElementMixed>, \"fespotlight\")>]\n        let FeSpotLight ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fespotlight\" ns\n        /// Create an SVG element <fetile> with children nodes.\n        [<Inline; CompiledName \"fetile\"; Macro(typeof<Macros.ElementMixed>, \"fetile\")>]\n        let FeTile ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"fetile\" ns\n        /// Create an SVG element <feturbulence> with children nodes.\n        [<Inline; CompiledName \"feturbulence\"; Macro(typeof<Macros.ElementMixed>, \"feturbulence\")>]\n        let FeTurbulence ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"feturbulence\" ns\n        /// Create an SVG element <filter> with children nodes.\n        [<Inline; CompiledName \"filter\"; Macro(typeof<Macros.ElementMixed>, \"filter\")>]\n        let Filter ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"filter\" ns\n        /// Create an SVG element <font> with children nodes.\n        [<Inline; CompiledName \"font\"; Macro(typeof<Macros.ElementMixed>, \"font\")>]\n        let Font ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"font\" ns\n        /// Create an SVG element <font-face> with children nodes.\n        [<Inline; CompiledName \"fontFace\"; Macro(typeof<Macros.ElementMixed>, \"font-face\")>]\n        let FontFace ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"font-face\" ns\n        /// Create an SVG element <font-face-format> with children nodes.\n        [<Inline; CompiledName \"fontFaceFormat\"; Macro(typeof<Macros.ElementMixed>, \"font-face-format\")>]\n        let FontFaceFormat ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"font-face-format\" ns\n        /// Create an SVG element <font-face-name> with children nodes.\n        [<Inline; CompiledName \"fontFaceName\"; Macro(typeof<Macros.ElementMixed>, \"font-face-name\")>]\n        let FontFaceName ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"font-face-name\" ns\n        /// Create an SVG element <font-face-src> with children nodes.\n        [<Inline; CompiledName \"fontFaceSrc\"; Macro(typeof<Macros.ElementMixed>, \"font-face-src\")>]\n        let FontFaceSrc ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"font-face-src\" ns\n        /// Create an SVG element <font-face-uri> with children nodes.\n        [<Inline; CompiledName \"fontFaceUri\"; Macro(typeof<Macros.ElementMixed>, \"font-face-uri\")>]\n        let FontFaceUri ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"font-face-uri\" ns\n        /// Create an SVG element <foreignobject> with children nodes.\n        [<Inline; CompiledName \"foreignobject\"; Macro(typeof<Macros.ElementMixed>, \"foreignobject\")>]\n        let ForeignObject ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"foreignobject\" ns\n        /// Create an SVG element <g> with children nodes.\n        [<Inline; CompiledName \"g\"; Macro(typeof<Macros.ElementMixed>, \"g\")>]\n        let G ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"g\" ns\n        /// Create an SVG element <glyph> with children nodes.\n        [<Inline; CompiledName \"glyph\"; Macro(typeof<Macros.ElementMixed>, \"glyph\")>]\n        let Glyph ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"glyph\" ns\n        /// Create an SVG element <glyphref> with children nodes.\n        [<Inline; CompiledName \"glyphref\"; Macro(typeof<Macros.ElementMixed>, \"glyphref\")>]\n        let GlyphRef ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"glyphref\" ns\n        /// Create an SVG element <hkern> with children nodes.\n        [<Inline; CompiledName \"hkern\"; Macro(typeof<Macros.ElementMixed>, \"hkern\")>]\n        let HKern ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"hkern\" ns\n        /// Create an SVG element <image> with children nodes.\n        [<Inline; CompiledName \"image\"; Macro(typeof<Macros.ElementMixed>, \"image\")>]\n        let Image ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"image\" ns\n        /// Create an SVG element <line> with children nodes.\n        [<Inline; CompiledName \"line\"; Macro(typeof<Macros.ElementMixed>, \"line\")>]\n        let Line ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"line\" ns\n        /// Create an SVG element <lineargradient> with children nodes.\n        [<Inline; CompiledName \"lineargradient\"; Macro(typeof<Macros.ElementMixed>, \"lineargradient\")>]\n        let LinearGradient ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"lineargradient\" ns\n        /// Create an SVG element <marker> with children nodes.\n        [<Inline; CompiledName \"marker\"; Macro(typeof<Macros.ElementMixed>, \"marker\")>]\n        let Marker ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"marker\" ns\n        /// Create an SVG element <mask> with children nodes.\n        [<Inline; CompiledName \"mask\"; Macro(typeof<Macros.ElementMixed>, \"mask\")>]\n        let Mask ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"mask\" ns\n        /// Create an SVG element <metadata> with children nodes.\n        [<Inline; CompiledName \"metadata\"; Macro(typeof<Macros.ElementMixed>, \"metadata\")>]\n        let Metadata ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"metadata\" ns\n        /// Create an SVG element <missing-glyph> with children nodes.\n        [<Inline; CompiledName \"missingGlyph\"; Macro(typeof<Macros.ElementMixed>, \"missing-glyph\")>]\n        let MissingGlyph ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"missing-glyph\" ns\n        /// Create an SVG element <mpath> with children nodes.\n        [<Inline; CompiledName \"mpath\"; Macro(typeof<Macros.ElementMixed>, \"mpath\")>]\n        let MPath ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"mpath\" ns\n        /// Create an SVG element <path> with children nodes.\n        [<Inline; CompiledName \"path\"; Macro(typeof<Macros.ElementMixed>, \"path\")>]\n        let Path ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"path\" ns\n        /// Create an SVG element <pattern> with children nodes.\n        [<Inline; CompiledName \"pattern\"; Macro(typeof<Macros.ElementMixed>, \"pattern\")>]\n        let Pattern ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"pattern\" ns\n        /// Create an SVG element <polygon> with children nodes.\n        [<Inline; CompiledName \"polygon\"; Macro(typeof<Macros.ElementMixed>, \"polygon\")>]\n        let Polygon ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"polygon\" ns\n        /// Create an SVG element <polyline> with children nodes.\n        [<Inline; CompiledName \"polyline\"; Macro(typeof<Macros.ElementMixed>, \"polyline\")>]\n        let Polyline ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"polyline\" ns\n        /// Create an SVG element <radialgradient> with children nodes.\n        [<Inline; CompiledName \"radialgradient\"; Macro(typeof<Macros.ElementMixed>, \"radialgradient\")>]\n        let RadialGradient ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"radialgradient\" ns\n        /// Create an SVG element <rect> with children nodes.\n        [<Inline; CompiledName \"rect\"; Macro(typeof<Macros.ElementMixed>, \"rect\")>]\n        let Rect ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"rect\" ns\n        /// Create an SVG element <script> with children nodes.\n        [<Inline; CompiledName \"script\"; Macro(typeof<Macros.ElementMixed>, \"script\")>]\n        let Script ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"script\" ns\n        /// Create an SVG element <set> with children nodes.\n        [<Inline; CompiledName \"set\"; Macro(typeof<Macros.ElementMixed>, \"set\")>]\n        let Set ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"set\" ns\n        /// Create an SVG element <stop> with children nodes.\n        [<Inline; CompiledName \"stop\"; Macro(typeof<Macros.ElementMixed>, \"stop\")>]\n        let Stop ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"stop\" ns\n        /// Create an SVG element <style> with children nodes.\n        [<Inline; CompiledName \"style\"; Macro(typeof<Macros.ElementMixed>, \"style\")>]\n        let Style ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"style\" ns\n        /// Create an SVG element <svg> with children nodes.\n        [<Inline; CompiledName \"svg\"; Macro(typeof<Macros.ElementMixed>, \"svg\")>]\n        let Svg ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"svg\" ns\n        /// Create an SVG element <switch> with children nodes.\n        [<Inline; CompiledName \"switch\"; Macro(typeof<Macros.ElementMixed>, \"switch\")>]\n        let Switch ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"switch\" ns\n        /// Create an SVG element <symbol> with children nodes.\n        [<Inline; CompiledName \"symbol\"; Macro(typeof<Macros.ElementMixed>, \"symbol\")>]\n        let Symbol ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"symbol\" ns\n        /// Create an SVG element <text> with children nodes.\n        [<Inline; CompiledName \"text\"; Macro(typeof<Macros.ElementMixed>, \"text\")>]\n        let Text ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"text\" ns\n        /// Create an SVG element <textpath> with children nodes.\n        [<Inline; CompiledName \"textpath\"; Macro(typeof<Macros.ElementMixed>, \"textpath\")>]\n        let TextPath ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"textpath\" ns\n        /// Create an SVG element <title> with children nodes.\n        [<Inline; CompiledName \"title\"; Macro(typeof<Macros.ElementMixed>, \"title\")>]\n        let Title ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"title\" ns\n        /// Create an SVG element <tref> with children nodes.\n        [<Inline; CompiledName \"tref\"; Macro(typeof<Macros.ElementMixed>, \"tref\")>]\n        let TRef ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"tref\" ns\n        /// Create an SVG element <tspan> with children nodes.\n        [<Inline; CompiledName \"tspan\"; Macro(typeof<Macros.ElementMixed>, \"tspan\")>]\n        let TSpan ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"tspan\" ns\n        /// Create an SVG element <use> with children nodes.\n        [<Inline; CompiledName \"use\"; Macro(typeof<Macros.ElementMixed>, \"use\")>]\n        let Use ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"use\" ns\n        /// Create an SVG element <view> with children nodes.\n        [<Inline; CompiledName \"view\"; Macro(typeof<Macros.ElementMixed>, \"view\")>]\n        let View ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"view\" ns\n        /// Create an SVG element <vkern> with children nodes.\n        [<Inline; CompiledName \"vkern\"; Macro(typeof<Macros.ElementMixed>, \"vkern\")>]\n        let VKern ([<ParamArray>] ns : obj[]) = Doc.SvgElementMixed \"vkern\" ns\n        // }}\n    \n    module attr =\n\n        /// Create an animated HTML attribute \"class\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"class\">]\n        let DynamicClass name view (apply: Predicate<_>) = Client.Attr.DynamicClass name view apply.Invoke\n\n        /// Create an HTML attribute \"data-name\" with the given value.\n        [<Inline>]\n        let ``data-`` name value = Attr.Create (\"data-\" + name) value\n        /// Create an HTML attribute \"data-name\" with the given reactive value.\n        [<Inline>]\n        let ``dataDyn-`` name view = Client.Attr.Dynamic (\"data-\" + name) view\n        /// `dataDynPred- p v` sets an HTML attribute \"data-name\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline>]\n        let ``dataDynPred-`` name pred view = Client.Attr.DynamicPred (\"data-\" + name) pred view\n        /// Create an animated HTML attribute \"data-name\" whose value is computed from the given reactive view.\n        [<Inline>]\n        let ``dataAnim-`` name view (convert: Func<_, string>) trans = Client.Attr.Animated (\"data-\" + name) trans view (FSharpConvert.Fun convert)\n\n        // {{ attr normal colliding deprecated\n        /// Create an HTML attribute \"accept\" with the given value.\n        [<Inline; CompiledName \"accept\"; Macro(typeof<Macros.AttrCreate>, \"accept\")>]\n        let Accept value = Attr.Create \"accept\" value\n        /// Create an HTML attribute \"accept\" with the given reactive value.\n        [<Inline; CompiledName \"accept\">]\n        let AcceptDyn view = Client.Attr.Dynamic \"accept\" view\n        /// `accept v p` sets an HTML attribute \"accept\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"accept\">]\n        let AcceptDynPred view pred = Client.Attr.DynamicPred \"accept\" pred view\n        /// Create an animated HTML attribute \"accept\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"accept\">]\n        let AcceptAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"accept\" trans view convert.Invoke\n        /// Create an HTML attribute \"accept-charset\" with the given value.\n        [<Inline; CompiledName \"acceptCharset\"; Macro(typeof<Macros.AttrCreate>, \"accept-charset\")>]\n        let AcceptCharSet value = Attr.Create \"accept-charset\" value\n        /// Create an HTML attribute \"accept-charset\" with the given reactive value.\n        [<Inline; CompiledName \"acceptCharset\">]\n        let AcceptCharSetDyn view = Client.Attr.Dynamic \"accept-charset\" view\n        /// `acceptCharset v p` sets an HTML attribute \"accept-charset\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"acceptCharset\">]\n        let AcceptCharSetDynPred view pred = Client.Attr.DynamicPred \"accept-charset\" pred view\n        /// Create an animated HTML attribute \"accept-charset\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"acceptCharset\">]\n        let AcceptCharSetAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"accept-charset\" trans view convert.Invoke\n        /// Create an HTML attribute \"accesskey\" with the given value.\n        [<Inline; CompiledName \"accesskey\"; Macro(typeof<Macros.AttrCreate>, \"accesskey\")>]\n        let AccessKey value = Attr.Create \"accesskey\" value\n        /// Create an HTML attribute \"accesskey\" with the given reactive value.\n        [<Inline; CompiledName \"accesskey\">]\n        let AccessKeyDyn view = Client.Attr.Dynamic \"accesskey\" view\n        /// `accesskey v p` sets an HTML attribute \"accesskey\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"accesskey\">]\n        let AccessKeyDynPred view pred = Client.Attr.DynamicPred \"accesskey\" pred view\n        /// Create an animated HTML attribute \"accesskey\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"accesskey\">]\n        let AccessKeyAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"accesskey\" trans view convert.Invoke\n        /// Create an HTML attribute \"action\" with the given value.\n        [<Inline; CompiledName \"action\"; Macro(typeof<Macros.AttrCreate>, \"action\")>]\n        let Action value = Attr.Create \"action\" value\n        /// Create an HTML attribute \"action\" with the given reactive value.\n        [<Inline; CompiledName \"action\">]\n        let ActionDyn view = Client.Attr.Dynamic \"action\" view\n        /// `action v p` sets an HTML attribute \"action\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"action\">]\n        let ActionDynPred view pred = Client.Attr.DynamicPred \"action\" pred view\n        /// Create an animated HTML attribute \"action\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"action\">]\n        let ActionAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"action\" trans view convert.Invoke\n        /// Create an HTML attribute \"align\" with the given value.\n        [<Inline; CompiledName \"align\"; Macro(typeof<Macros.AttrCreate>, \"align\")>]\n        let Align value = Attr.Create \"align\" value\n        /// Create an HTML attribute \"align\" with the given reactive value.\n        [<Inline; CompiledName \"align\">]\n        let AlignDyn view = Client.Attr.Dynamic \"align\" view\n        /// `align v p` sets an HTML attribute \"align\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"align\">]\n        let AlignDynPred view pred = Client.Attr.DynamicPred \"align\" pred view\n        /// Create an animated HTML attribute \"align\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"align\">]\n        let AlignAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"align\" trans view convert.Invoke\n        /// Create an HTML attribute \"alink\" with the given value.\n        [<Inline; CompiledName \"alink\"; Macro(typeof<Macros.AttrCreate>, \"alink\")>]\n        let Alink value = Attr.Create \"alink\" value\n        /// Create an HTML attribute \"alink\" with the given reactive value.\n        [<Inline; CompiledName \"alink\">]\n        let AlinkDyn view = Client.Attr.Dynamic \"alink\" view\n        /// `alink v p` sets an HTML attribute \"alink\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"alink\">]\n        let AlinkDynPred view pred = Client.Attr.DynamicPred \"alink\" pred view\n        /// Create an animated HTML attribute \"alink\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"alink\">]\n        let AlinkAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"alink\" trans view convert.Invoke\n        /// Create an HTML attribute \"alt\" with the given value.\n        [<Inline; CompiledName \"alt\"; Macro(typeof<Macros.AttrCreate>, \"alt\")>]\n        let Alt value = Attr.Create \"alt\" value\n        /// Create an HTML attribute \"alt\" with the given reactive value.\n        [<Inline; CompiledName \"alt\">]\n        let AltDyn view = Client.Attr.Dynamic \"alt\" view\n        /// `alt v p` sets an HTML attribute \"alt\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"alt\">]\n        let AltDynPred view pred = Client.Attr.DynamicPred \"alt\" pred view\n        /// Create an animated HTML attribute \"alt\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"alt\">]\n        let AltAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"alt\" trans view convert.Invoke\n        /// Create an HTML attribute \"altcode\" with the given value.\n        [<Inline; CompiledName \"altcode\"; Macro(typeof<Macros.AttrCreate>, \"altcode\")>]\n        let AltCode value = Attr.Create \"altcode\" value\n        /// Create an HTML attribute \"altcode\" with the given reactive value.\n        [<Inline; CompiledName \"altcode\">]\n        let AltCodeDyn view = Client.Attr.Dynamic \"altcode\" view\n        /// `altcode v p` sets an HTML attribute \"altcode\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"altcode\">]\n        let AltCodeDynPred view pred = Client.Attr.DynamicPred \"altcode\" pred view\n        /// Create an animated HTML attribute \"altcode\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"altcode\">]\n        let AltCodeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"altcode\" trans view convert.Invoke\n        /// Create an HTML attribute \"archive\" with the given value.\n        [<Inline; CompiledName \"archive\"; Macro(typeof<Macros.AttrCreate>, \"archive\")>]\n        let Archive value = Attr.Create \"archive\" value\n        /// Create an HTML attribute \"archive\" with the given reactive value.\n        [<Inline; CompiledName \"archive\">]\n        let ArchiveDyn view = Client.Attr.Dynamic \"archive\" view\n        /// `archive v p` sets an HTML attribute \"archive\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"archive\">]\n        let ArchiveDynPred view pred = Client.Attr.DynamicPred \"archive\" pred view\n        /// Create an animated HTML attribute \"archive\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"archive\">]\n        let ArchiveAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"archive\" trans view convert.Invoke\n        /// Create an HTML attribute \"async\" with the given value.\n        [<Inline; CompiledName \"async\"; Macro(typeof<Macros.AttrCreate>, \"async\")>]\n        let Async value = Attr.Create \"async\" value\n        /// Create an HTML attribute \"async\" with the given reactive value.\n        [<Inline; CompiledName \"async\">]\n        let AsyncDyn view = Client.Attr.Dynamic \"async\" view\n        /// `async v p` sets an HTML attribute \"async\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"async\">]\n        let AsyncDynPred view pred = Client.Attr.DynamicPred \"async\" pred view\n        /// Create an animated HTML attribute \"async\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"async\">]\n        let AsyncAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"async\" trans view convert.Invoke\n        /// Create an HTML attribute \"autocomplete\" with the given value.\n        [<Inline; CompiledName \"autocomplete\"; Macro(typeof<Macros.AttrCreate>, \"autocomplete\")>]\n        let AutoComplete value = Attr.Create \"autocomplete\" value\n        /// Create an HTML attribute \"autocomplete\" with the given reactive value.\n        [<Inline; CompiledName \"autocomplete\">]\n        let AutoCompleteDyn view = Client.Attr.Dynamic \"autocomplete\" view\n        /// `autocomplete v p` sets an HTML attribute \"autocomplete\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"autocomplete\">]\n        let AutoCompleteDynPred view pred = Client.Attr.DynamicPred \"autocomplete\" pred view\n        /// Create an animated HTML attribute \"autocomplete\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"autocomplete\">]\n        let AutoCompleteAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"autocomplete\" trans view convert.Invoke\n        /// Create an HTML attribute \"autofocus\" with the given value.\n        [<Inline; CompiledName \"autofocus\"; Macro(typeof<Macros.AttrCreate>, \"autofocus\")>]\n        let AutoFocus value = Attr.Create \"autofocus\" value\n        /// Create an HTML attribute \"autofocus\" with the given reactive value.\n        [<Inline; CompiledName \"autofocus\">]\n        let AutoFocusDyn view = Client.Attr.Dynamic \"autofocus\" view\n        /// `autofocus v p` sets an HTML attribute \"autofocus\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"autofocus\">]\n        let AutoFocusDynPred view pred = Client.Attr.DynamicPred \"autofocus\" pred view\n        /// Create an animated HTML attribute \"autofocus\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"autofocus\">]\n        let AutoFocusAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"autofocus\" trans view convert.Invoke\n        /// Create an HTML attribute \"autoplay\" with the given value.\n        [<Inline; CompiledName \"autoplay\"; Macro(typeof<Macros.AttrCreate>, \"autoplay\")>]\n        let AutoPlay value = Attr.Create \"autoplay\" value\n        /// Create an HTML attribute \"autoplay\" with the given reactive value.\n        [<Inline; CompiledName \"autoplay\">]\n        let AutoPlayDyn view = Client.Attr.Dynamic \"autoplay\" view\n        /// `autoplay v p` sets an HTML attribute \"autoplay\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"autoplay\">]\n        let AutoPlayDynPred view pred = Client.Attr.DynamicPred \"autoplay\" pred view\n        /// Create an animated HTML attribute \"autoplay\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"autoplay\">]\n        let AutoPlayAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"autoplay\" trans view convert.Invoke\n        /// Create an HTML attribute \"autosave\" with the given value.\n        [<Inline; CompiledName \"autosave\"; Macro(typeof<Macros.AttrCreate>, \"autosave\")>]\n        let AutoSave value = Attr.Create \"autosave\" value\n        /// Create an HTML attribute \"autosave\" with the given reactive value.\n        [<Inline; CompiledName \"autosave\">]\n        let AutoSaveDyn view = Client.Attr.Dynamic \"autosave\" view\n        /// `autosave v p` sets an HTML attribute \"autosave\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"autosave\">]\n        let AutoSaveDynPred view pred = Client.Attr.DynamicPred \"autosave\" pred view\n        /// Create an animated HTML attribute \"autosave\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"autosave\">]\n        let AutoSaveAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"autosave\" trans view convert.Invoke\n        /// Create an HTML attribute \"axis\" with the given value.\n        [<Inline; CompiledName \"axis\"; Macro(typeof<Macros.AttrCreate>, \"axis\")>]\n        let Axis value = Attr.Create \"axis\" value\n        /// Create an HTML attribute \"axis\" with the given reactive value.\n        [<Inline; CompiledName \"axis\">]\n        let AxisDyn view = Client.Attr.Dynamic \"axis\" view\n        /// `axis v p` sets an HTML attribute \"axis\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"axis\">]\n        let AxisDynPred view pred = Client.Attr.DynamicPred \"axis\" pred view\n        /// Create an animated HTML attribute \"axis\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"axis\">]\n        let AxisAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"axis\" trans view convert.Invoke\n        /// Create an HTML attribute \"background\" with the given value.\n        [<Inline; CompiledName \"background\"; Macro(typeof<Macros.AttrCreate>, \"background\")>]\n        let Background value = Attr.Create \"background\" value\n        /// Create an HTML attribute \"background\" with the given reactive value.\n        [<Inline; CompiledName \"background\">]\n        let BackgroundDyn view = Client.Attr.Dynamic \"background\" view\n        /// `background v p` sets an HTML attribute \"background\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"background\">]\n        let BackgroundDynPred view pred = Client.Attr.DynamicPred \"background\" pred view\n        /// Create an animated HTML attribute \"background\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"background\">]\n        let BackgroundAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"background\" trans view convert.Invoke\n        /// Create an HTML attribute \"bgcolor\" with the given value.\n        [<Inline; CompiledName \"bgcolor\"; Macro(typeof<Macros.AttrCreate>, \"bgcolor\")>]\n        let BgColor value = Attr.Create \"bgcolor\" value\n        /// Create an HTML attribute \"bgcolor\" with the given reactive value.\n        [<Inline; CompiledName \"bgcolor\">]\n        let BgColorDyn view = Client.Attr.Dynamic \"bgcolor\" view\n        /// `bgcolor v p` sets an HTML attribute \"bgcolor\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"bgcolor\">]\n        let BgColorDynPred view pred = Client.Attr.DynamicPred \"bgcolor\" pred view\n        /// Create an animated HTML attribute \"bgcolor\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"bgcolor\">]\n        let BgColorAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"bgcolor\" trans view convert.Invoke\n        /// Create an HTML attribute \"border\" with the given value.\n        [<Inline; CompiledName \"border\"; Macro(typeof<Macros.AttrCreate>, \"border\")>]\n        let Border value = Attr.Create \"border\" value\n        /// Create an HTML attribute \"border\" with the given reactive value.\n        [<Inline; CompiledName \"border\">]\n        let BorderDyn view = Client.Attr.Dynamic \"border\" view\n        /// `border v p` sets an HTML attribute \"border\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"border\">]\n        let BorderDynPred view pred = Client.Attr.DynamicPred \"border\" pred view\n        /// Create an animated HTML attribute \"border\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"border\">]\n        let BorderAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"border\" trans view convert.Invoke\n        /// Create an HTML attribute \"bordercolor\" with the given value.\n        [<Inline; CompiledName \"bordercolor\"; Macro(typeof<Macros.AttrCreate>, \"bordercolor\")>]\n        let BorderColor value = Attr.Create \"bordercolor\" value\n        /// Create an HTML attribute \"bordercolor\" with the given reactive value.\n        [<Inline; CompiledName \"bordercolor\">]\n        let BorderColorDyn view = Client.Attr.Dynamic \"bordercolor\" view\n        /// `bordercolor v p` sets an HTML attribute \"bordercolor\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"bordercolor\">]\n        let BorderColorDynPred view pred = Client.Attr.DynamicPred \"bordercolor\" pred view\n        /// Create an animated HTML attribute \"bordercolor\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"bordercolor\">]\n        let BorderColorAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"bordercolor\" trans view convert.Invoke\n        /// Create an HTML attribute \"buffered\" with the given value.\n        [<Inline; CompiledName \"buffered\"; Macro(typeof<Macros.AttrCreate>, \"buffered\")>]\n        let Buffered value = Attr.Create \"buffered\" value\n        /// Create an HTML attribute \"buffered\" with the given reactive value.\n        [<Inline; CompiledName \"buffered\">]\n        let BufferedDyn view = Client.Attr.Dynamic \"buffered\" view\n        /// `buffered v p` sets an HTML attribute \"buffered\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"buffered\">]\n        let BufferedDynPred view pred = Client.Attr.DynamicPred \"buffered\" pred view\n        /// Create an animated HTML attribute \"buffered\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"buffered\">]\n        let BufferedAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"buffered\" trans view convert.Invoke\n        /// Create an HTML attribute \"cellpadding\" with the given value.\n        [<Inline; CompiledName \"cellpadding\"; Macro(typeof<Macros.AttrCreate>, \"cellpadding\")>]\n        let CellPadding value = Attr.Create \"cellpadding\" value\n        /// Create an HTML attribute \"cellpadding\" with the given reactive value.\n        [<Inline; CompiledName \"cellpadding\">]\n        let CellPaddingDyn view = Client.Attr.Dynamic \"cellpadding\" view\n        /// `cellpadding v p` sets an HTML attribute \"cellpadding\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"cellpadding\">]\n        let CellPaddingDynPred view pred = Client.Attr.DynamicPred \"cellpadding\" pred view\n        /// Create an animated HTML attribute \"cellpadding\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"cellpadding\">]\n        let CellPaddingAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"cellpadding\" trans view convert.Invoke\n        /// Create an HTML attribute \"cellspacing\" with the given value.\n        [<Inline; CompiledName \"cellspacing\"; Macro(typeof<Macros.AttrCreate>, \"cellspacing\")>]\n        let CellSpacing value = Attr.Create \"cellspacing\" value\n        /// Create an HTML attribute \"cellspacing\" with the given reactive value.\n        [<Inline; CompiledName \"cellspacing\">]\n        let CellSpacingDyn view = Client.Attr.Dynamic \"cellspacing\" view\n        /// `cellspacing v p` sets an HTML attribute \"cellspacing\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"cellspacing\">]\n        let CellSpacingDynPred view pred = Client.Attr.DynamicPred \"cellspacing\" pred view\n        /// Create an animated HTML attribute \"cellspacing\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"cellspacing\">]\n        let CellSpacingAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"cellspacing\" trans view convert.Invoke\n        /// Create an HTML attribute \"challenge\" with the given value.\n        [<Inline; CompiledName \"challenge\"; Macro(typeof<Macros.AttrCreate>, \"challenge\")>]\n        let Challenge value = Attr.Create \"challenge\" value\n        /// Create an HTML attribute \"challenge\" with the given reactive value.\n        [<Inline; CompiledName \"challenge\">]\n        let ChallengeDyn view = Client.Attr.Dynamic \"challenge\" view\n        /// `challenge v p` sets an HTML attribute \"challenge\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"challenge\">]\n        let ChallengeDynPred view pred = Client.Attr.DynamicPred \"challenge\" pred view\n        /// Create an animated HTML attribute \"challenge\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"challenge\">]\n        let ChallengeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"challenge\" trans view convert.Invoke\n        /// Create an HTML attribute \"char\" with the given value.\n        [<Inline; CompiledName \"char\"; Macro(typeof<Macros.AttrCreate>, \"char\")>]\n        let Char value = Attr.Create \"char\" value\n        /// Create an HTML attribute \"char\" with the given reactive value.\n        [<Inline; CompiledName \"char\">]\n        let CharDyn view = Client.Attr.Dynamic \"char\" view\n        /// `char v p` sets an HTML attribute \"char\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"char\">]\n        let CharDynPred view pred = Client.Attr.DynamicPred \"char\" pred view\n        /// Create an animated HTML attribute \"char\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"char\">]\n        let CharAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"char\" trans view convert.Invoke\n        /// Create an HTML attribute \"charoff\" with the given value.\n        [<Inline; CompiledName \"charoff\"; Macro(typeof<Macros.AttrCreate>, \"charoff\")>]\n        let CharOff value = Attr.Create \"charoff\" value\n        /// Create an HTML attribute \"charoff\" with the given reactive value.\n        [<Inline; CompiledName \"charoff\">]\n        let CharOffDyn view = Client.Attr.Dynamic \"charoff\" view\n        /// `charoff v p` sets an HTML attribute \"charoff\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"charoff\">]\n        let CharOffDynPred view pred = Client.Attr.DynamicPred \"charoff\" pred view\n        /// Create an animated HTML attribute \"charoff\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"charoff\">]\n        let CharOffAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"charoff\" trans view convert.Invoke\n        /// Create an HTML attribute \"charset\" with the given value.\n        [<Inline; CompiledName \"charset\"; Macro(typeof<Macros.AttrCreate>, \"charset\")>]\n        let CharSet value = Attr.Create \"charset\" value\n        /// Create an HTML attribute \"charset\" with the given reactive value.\n        [<Inline; CompiledName \"charset\">]\n        let CharSetDyn view = Client.Attr.Dynamic \"charset\" view\n        /// `charset v p` sets an HTML attribute \"charset\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"charset\">]\n        let CharSetDynPred view pred = Client.Attr.DynamicPred \"charset\" pred view\n        /// Create an animated HTML attribute \"charset\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"charset\">]\n        let CharSetAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"charset\" trans view convert.Invoke\n        /// Create an HTML attribute \"checked\" with the given value.\n        [<Inline; CompiledName \"checked\"; Macro(typeof<Macros.AttrCreate>, \"checked\")>]\n        let Checked value = Attr.Create \"checked\" value\n        /// Create an HTML attribute \"checked\" with the given reactive value.\n        [<Inline; CompiledName \"checked\">]\n        let CheckedDyn view = Client.Attr.Dynamic \"checked\" view\n        /// `checked v p` sets an HTML attribute \"checked\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"checked\">]\n        let CheckedDynPred view pred = Client.Attr.DynamicPred \"checked\" pred view\n        /// Create an animated HTML attribute \"checked\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"checked\">]\n        let CheckedAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"checked\" trans view convert.Invoke\n        /// Create an HTML attribute \"cite\" with the given value.\n        [<Inline; CompiledName \"cite\"; Macro(typeof<Macros.AttrCreate>, \"cite\")>]\n        let Cite value = Attr.Create \"cite\" value\n        /// Create an HTML attribute \"cite\" with the given reactive value.\n        [<Inline; CompiledName \"cite\">]\n        let CiteDyn view = Client.Attr.Dynamic \"cite\" view\n        /// `cite v p` sets an HTML attribute \"cite\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"cite\">]\n        let CiteDynPred view pred = Client.Attr.DynamicPred \"cite\" pred view\n        /// Create an animated HTML attribute \"cite\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"cite\">]\n        let CiteAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"cite\" trans view convert.Invoke\n        /// Create an HTML attribute \"class\" with the given value.\n        [<Inline; CompiledName \"class\"; Macro(typeof<Macros.AttrCreate>, \"class\")>]\n        let Class value = Attr.Create \"class\" value\n        /// Create an HTML attribute \"class\" with the given reactive value.\n        [<Inline; CompiledName \"class\">]\n        let ClassDyn view = Client.Attr.Dynamic \"class\" view\n        /// `class v p` sets an HTML attribute \"class\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"class\">]\n        let ClassDynPred view pred = Client.Attr.DynamicPred \"class\" pred view\n        /// Create an animated HTML attribute \"class\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"class\">]\n        let ClassAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"class\" trans view convert.Invoke\n        /// Create an HTML attribute \"classid\" with the given value.\n        [<Inline; CompiledName \"classid\"; Macro(typeof<Macros.AttrCreate>, \"classid\")>]\n        let ClassId value = Attr.Create \"classid\" value\n        /// Create an HTML attribute \"classid\" with the given reactive value.\n        [<Inline; CompiledName \"classid\">]\n        let ClassIdDyn view = Client.Attr.Dynamic \"classid\" view\n        /// `classid v p` sets an HTML attribute \"classid\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"classid\">]\n        let ClassIdDynPred view pred = Client.Attr.DynamicPred \"classid\" pred view\n        /// Create an animated HTML attribute \"classid\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"classid\">]\n        let ClassIdAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"classid\" trans view convert.Invoke\n        /// Create an HTML attribute \"clear\" with the given value.\n        [<Inline; CompiledName \"clear\"; Macro(typeof<Macros.AttrCreate>, \"clear\")>]\n        let Clear value = Attr.Create \"clear\" value\n        /// Create an HTML attribute \"clear\" with the given reactive value.\n        [<Inline; CompiledName \"clear\">]\n        let ClearDyn view = Client.Attr.Dynamic \"clear\" view\n        /// `clear v p` sets an HTML attribute \"clear\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"clear\">]\n        let ClearDynPred view pred = Client.Attr.DynamicPred \"clear\" pred view\n        /// Create an animated HTML attribute \"clear\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"clear\">]\n        let ClearAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"clear\" trans view convert.Invoke\n        /// Create an HTML attribute \"code\" with the given value.\n        [<Inline; CompiledName \"code\"; Macro(typeof<Macros.AttrCreate>, \"code\")>]\n        let Code value = Attr.Create \"code\" value\n        /// Create an HTML attribute \"code\" with the given reactive value.\n        [<Inline; CompiledName \"code\">]\n        let CodeDyn view = Client.Attr.Dynamic \"code\" view\n        /// `code v p` sets an HTML attribute \"code\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"code\">]\n        let CodeDynPred view pred = Client.Attr.DynamicPred \"code\" pred view\n        /// Create an animated HTML attribute \"code\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"code\">]\n        let CodeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"code\" trans view convert.Invoke\n        /// Create an HTML attribute \"codebase\" with the given value.\n        [<Inline; CompiledName \"codebase\"; Macro(typeof<Macros.AttrCreate>, \"codebase\")>]\n        let CodeBase value = Attr.Create \"codebase\" value\n        /// Create an HTML attribute \"codebase\" with the given reactive value.\n        [<Inline; CompiledName \"codebase\">]\n        let CodeBaseDyn view = Client.Attr.Dynamic \"codebase\" view\n        /// `codebase v p` sets an HTML attribute \"codebase\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"codebase\">]\n        let CodeBaseDynPred view pred = Client.Attr.DynamicPred \"codebase\" pred view\n        /// Create an animated HTML attribute \"codebase\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"codebase\">]\n        let CodeBaseAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"codebase\" trans view convert.Invoke\n        /// Create an HTML attribute \"codetype\" with the given value.\n        [<Inline; CompiledName \"codetype\"; Macro(typeof<Macros.AttrCreate>, \"codetype\")>]\n        let CodeType value = Attr.Create \"codetype\" value\n        /// Create an HTML attribute \"codetype\" with the given reactive value.\n        [<Inline; CompiledName \"codetype\">]\n        let CodeTypeDyn view = Client.Attr.Dynamic \"codetype\" view\n        /// `codetype v p` sets an HTML attribute \"codetype\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"codetype\">]\n        let CodeTypeDynPred view pred = Client.Attr.DynamicPred \"codetype\" pred view\n        /// Create an animated HTML attribute \"codetype\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"codetype\">]\n        let CodeTypeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"codetype\" trans view convert.Invoke\n        /// Create an HTML attribute \"color\" with the given value.\n        [<Inline; CompiledName \"color\"; Macro(typeof<Macros.AttrCreate>, \"color\")>]\n        let Color value = Attr.Create \"color\" value\n        /// Create an HTML attribute \"color\" with the given reactive value.\n        [<Inline; CompiledName \"color\">]\n        let ColorDyn view = Client.Attr.Dynamic \"color\" view\n        /// `color v p` sets an HTML attribute \"color\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"color\">]\n        let ColorDynPred view pred = Client.Attr.DynamicPred \"color\" pred view\n        /// Create an animated HTML attribute \"color\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"color\">]\n        let ColorAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"color\" trans view convert.Invoke\n        /// Create an HTML attribute \"cols\" with the given value.\n        [<Inline; CompiledName \"cols\"; Macro(typeof<Macros.AttrCreate>, \"cols\")>]\n        let Cols value = Attr.Create \"cols\" value\n        /// Create an HTML attribute \"cols\" with the given reactive value.\n        [<Inline; CompiledName \"cols\">]\n        let ColsDyn view = Client.Attr.Dynamic \"cols\" view\n        /// `cols v p` sets an HTML attribute \"cols\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"cols\">]\n        let ColsDynPred view pred = Client.Attr.DynamicPred \"cols\" pred view\n        /// Create an animated HTML attribute \"cols\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"cols\">]\n        let ColsAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"cols\" trans view convert.Invoke\n        /// Create an HTML attribute \"colspan\" with the given value.\n        [<Inline; CompiledName \"colspan\"; Macro(typeof<Macros.AttrCreate>, \"colspan\")>]\n        let ColSpan value = Attr.Create \"colspan\" value\n        /// Create an HTML attribute \"colspan\" with the given reactive value.\n        [<Inline; CompiledName \"colspan\">]\n        let ColSpanDyn view = Client.Attr.Dynamic \"colspan\" view\n        /// `colspan v p` sets an HTML attribute \"colspan\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"colspan\">]\n        let ColSpanDynPred view pred = Client.Attr.DynamicPred \"colspan\" pred view\n        /// Create an animated HTML attribute \"colspan\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"colspan\">]\n        let ColSpanAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"colspan\" trans view convert.Invoke\n        /// Create an HTML attribute \"compact\" with the given value.\n        [<Inline; CompiledName \"compact\"; Macro(typeof<Macros.AttrCreate>, \"compact\")>]\n        let Compact value = Attr.Create \"compact\" value\n        /// Create an HTML attribute \"compact\" with the given reactive value.\n        [<Inline; CompiledName \"compact\">]\n        let CompactDyn view = Client.Attr.Dynamic \"compact\" view\n        /// `compact v p` sets an HTML attribute \"compact\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"compact\">]\n        let CompactDynPred view pred = Client.Attr.DynamicPred \"compact\" pred view\n        /// Create an animated HTML attribute \"compact\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"compact\">]\n        let CompactAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"compact\" trans view convert.Invoke\n        /// Create an HTML attribute \"content\" with the given value.\n        [<Inline; CompiledName \"content\"; Macro(typeof<Macros.AttrCreate>, \"content\")>]\n        let Content value = Attr.Create \"content\" value\n        /// Create an HTML attribute \"content\" with the given reactive value.\n        [<Inline; CompiledName \"content\">]\n        let ContentDyn view = Client.Attr.Dynamic \"content\" view\n        /// `content v p` sets an HTML attribute \"content\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"content\">]\n        let ContentDynPred view pred = Client.Attr.DynamicPred \"content\" pred view\n        /// Create an animated HTML attribute \"content\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"content\">]\n        let ContentAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"content\" trans view convert.Invoke\n        /// Create an HTML attribute \"contenteditable\" with the given value.\n        [<Inline; CompiledName \"contenteditable\"; Macro(typeof<Macros.AttrCreate>, \"contenteditable\")>]\n        let ContentEditable value = Attr.Create \"contenteditable\" value\n        /// Create an HTML attribute \"contenteditable\" with the given reactive value.\n        [<Inline; CompiledName \"contenteditable\">]\n        let ContentEditableDyn view = Client.Attr.Dynamic \"contenteditable\" view\n        /// `contenteditable v p` sets an HTML attribute \"contenteditable\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"contenteditable\">]\n        let ContentEditableDynPred view pred = Client.Attr.DynamicPred \"contenteditable\" pred view\n        /// Create an animated HTML attribute \"contenteditable\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"contenteditable\">]\n        let ContentEditableAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"contenteditable\" trans view convert.Invoke\n        /// Create an HTML attribute \"contextmenu\" with the given value.\n        [<Inline; CompiledName \"contextmenu\"; Macro(typeof<Macros.AttrCreate>, \"contextmenu\")>]\n        let ContextMenu value = Attr.Create \"contextmenu\" value\n        /// Create an HTML attribute \"contextmenu\" with the given reactive value.\n        [<Inline; CompiledName \"contextmenu\">]\n        let ContextMenuDyn view = Client.Attr.Dynamic \"contextmenu\" view\n        /// `contextmenu v p` sets an HTML attribute \"contextmenu\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"contextmenu\">]\n        let ContextMenuDynPred view pred = Client.Attr.DynamicPred \"contextmenu\" pred view\n        /// Create an animated HTML attribute \"contextmenu\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"contextmenu\">]\n        let ContextMenuAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"contextmenu\" trans view convert.Invoke\n        /// Create an HTML attribute \"controls\" with the given value.\n        [<Inline; CompiledName \"controls\"; Macro(typeof<Macros.AttrCreate>, \"controls\")>]\n        let Controls value = Attr.Create \"controls\" value\n        /// Create an HTML attribute \"controls\" with the given reactive value.\n        [<Inline; CompiledName \"controls\">]\n        let ControlsDyn view = Client.Attr.Dynamic \"controls\" view\n        /// `controls v p` sets an HTML attribute \"controls\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"controls\">]\n        let ControlsDynPred view pred = Client.Attr.DynamicPred \"controls\" pred view\n        /// Create an animated HTML attribute \"controls\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"controls\">]\n        let ControlsAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"controls\" trans view convert.Invoke\n        /// Create an HTML attribute \"coords\" with the given value.\n        [<Inline; CompiledName \"coords\"; Macro(typeof<Macros.AttrCreate>, \"coords\")>]\n        let Coords value = Attr.Create \"coords\" value\n        /// Create an HTML attribute \"coords\" with the given reactive value.\n        [<Inline; CompiledName \"coords\">]\n        let CoordsDyn view = Client.Attr.Dynamic \"coords\" view\n        /// `coords v p` sets an HTML attribute \"coords\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"coords\">]\n        let CoordsDynPred view pred = Client.Attr.DynamicPred \"coords\" pred view\n        /// Create an animated HTML attribute \"coords\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"coords\">]\n        let CoordsAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"coords\" trans view convert.Invoke\n        /// Create an HTML attribute \"data\" with the given value.\n        [<Inline; CompiledName \"data\"; Macro(typeof<Macros.AttrCreate>, \"data\")>]\n        let Data value = Attr.Create \"data\" value\n        /// Create an HTML attribute \"data\" with the given reactive value.\n        [<Inline; CompiledName \"data\">]\n        let DataDyn view = Client.Attr.Dynamic \"data\" view\n        /// `data v p` sets an HTML attribute \"data\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"data\">]\n        let DataDynPred view pred = Client.Attr.DynamicPred \"data\" pred view\n        /// Create an animated HTML attribute \"data\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"data\">]\n        let DataAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"data\" trans view convert.Invoke\n        /// Create an HTML attribute \"datetime\" with the given value.\n        [<Inline; CompiledName \"datetime\"; Macro(typeof<Macros.AttrCreate>, \"datetime\")>]\n        let DateTime value = Attr.Create \"datetime\" value\n        /// Create an HTML attribute \"datetime\" with the given reactive value.\n        [<Inline; CompiledName \"datetime\">]\n        let DateTimeDyn view = Client.Attr.Dynamic \"datetime\" view\n        /// `datetime v p` sets an HTML attribute \"datetime\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"datetime\">]\n        let DateTimeDynPred view pred = Client.Attr.DynamicPred \"datetime\" pred view\n        /// Create an animated HTML attribute \"datetime\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"datetime\">]\n        let DateTimeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"datetime\" trans view convert.Invoke\n        /// Create an HTML attribute \"declare\" with the given value.\n        [<Inline; CompiledName \"declare\"; Macro(typeof<Macros.AttrCreate>, \"declare\")>]\n        let Declare value = Attr.Create \"declare\" value\n        /// Create an HTML attribute \"declare\" with the given reactive value.\n        [<Inline; CompiledName \"declare\">]\n        let DeclareDyn view = Client.Attr.Dynamic \"declare\" view\n        /// `declare v p` sets an HTML attribute \"declare\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"declare\">]\n        let DeclareDynPred view pred = Client.Attr.DynamicPred \"declare\" pred view\n        /// Create an animated HTML attribute \"declare\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"declare\">]\n        let DeclareAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"declare\" trans view convert.Invoke\n        /// Create an HTML attribute \"default\" with the given value.\n        [<Inline; CompiledName \"default\"; Macro(typeof<Macros.AttrCreate>, \"default\")>]\n        let Default value = Attr.Create \"default\" value\n        /// Create an HTML attribute \"default\" with the given reactive value.\n        [<Inline; CompiledName \"default\">]\n        let DefaultDyn view = Client.Attr.Dynamic \"default\" view\n        /// `default v p` sets an HTML attribute \"default\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"default\">]\n        let DefaultDynPred view pred = Client.Attr.DynamicPred \"default\" pred view\n        /// Create an animated HTML attribute \"default\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"default\">]\n        let DefaultAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"default\" trans view convert.Invoke\n        /// Create an HTML attribute \"defer\" with the given value.\n        [<Inline; CompiledName \"defer\"; Macro(typeof<Macros.AttrCreate>, \"defer\")>]\n        let Defer value = Attr.Create \"defer\" value\n        /// Create an HTML attribute \"defer\" with the given reactive value.\n        [<Inline; CompiledName \"defer\">]\n        let DeferDyn view = Client.Attr.Dynamic \"defer\" view\n        /// `defer v p` sets an HTML attribute \"defer\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"defer\">]\n        let DeferDynPred view pred = Client.Attr.DynamicPred \"defer\" pred view\n        /// Create an animated HTML attribute \"defer\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"defer\">]\n        let DeferAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"defer\" trans view convert.Invoke\n        /// Create an HTML attribute \"dir\" with the given value.\n        [<Inline; CompiledName \"dir\"; Macro(typeof<Macros.AttrCreate>, \"dir\")>]\n        let Dir value = Attr.Create \"dir\" value\n        /// Create an HTML attribute \"dir\" with the given reactive value.\n        [<Inline; CompiledName \"dir\">]\n        let DirDyn view = Client.Attr.Dynamic \"dir\" view\n        /// `dir v p` sets an HTML attribute \"dir\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"dir\">]\n        let DirDynPred view pred = Client.Attr.DynamicPred \"dir\" pred view\n        /// Create an animated HTML attribute \"dir\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"dir\">]\n        let DirAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"dir\" trans view convert.Invoke\n        /// Create an HTML attribute \"disabled\" with the given value.\n        [<Inline; CompiledName \"disabled\"; Macro(typeof<Macros.AttrCreate>, \"disabled\")>]\n        let Disabled value = Attr.Create \"disabled\" value\n        /// Create an HTML attribute \"disabled\" with the given reactive value.\n        [<Inline; CompiledName \"disabled\">]\n        let DisabledDyn view = Client.Attr.Dynamic \"disabled\" view\n        /// `disabled v p` sets an HTML attribute \"disabled\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"disabled\">]\n        let DisabledDynPred view pred = Client.Attr.DynamicPred \"disabled\" pred view\n        /// Create an animated HTML attribute \"disabled\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"disabled\">]\n        let DisabledAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"disabled\" trans view convert.Invoke\n        /// Create an HTML attribute \"download\" with the given value.\n        [<Inline; CompiledName \"download\"; Macro(typeof<Macros.AttrCreate>, \"download\")>]\n        let Download value = Attr.Create \"download\" value\n        /// Create an HTML attribute \"download\" with the given reactive value.\n        [<Inline; CompiledName \"download\">]\n        let DownloadDyn view = Client.Attr.Dynamic \"download\" view\n        /// `download v p` sets an HTML attribute \"download\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"download\">]\n        let DownloadDynPred view pred = Client.Attr.DynamicPred \"download\" pred view\n        /// Create an animated HTML attribute \"download\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"download\">]\n        let DownloadAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"download\" trans view convert.Invoke\n        /// Create an HTML attribute \"draggable\" with the given value.\n        [<Inline; CompiledName \"draggable\"; Macro(typeof<Macros.AttrCreate>, \"draggable\")>]\n        let Draggable value = Attr.Create \"draggable\" value\n        /// Create an HTML attribute \"draggable\" with the given reactive value.\n        [<Inline; CompiledName \"draggable\">]\n        let DraggableDyn view = Client.Attr.Dynamic \"draggable\" view\n        /// `draggable v p` sets an HTML attribute \"draggable\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"draggable\">]\n        let DraggableDynPred view pred = Client.Attr.DynamicPred \"draggable\" pred view\n        /// Create an animated HTML attribute \"draggable\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"draggable\">]\n        let DraggableAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"draggable\" trans view convert.Invoke\n        /// Create an HTML attribute \"dropzone\" with the given value.\n        [<Inline; CompiledName \"dropzone\"; Macro(typeof<Macros.AttrCreate>, \"dropzone\")>]\n        let DropZone value = Attr.Create \"dropzone\" value\n        /// Create an HTML attribute \"dropzone\" with the given reactive value.\n        [<Inline; CompiledName \"dropzone\">]\n        let DropZoneDyn view = Client.Attr.Dynamic \"dropzone\" view\n        /// `dropzone v p` sets an HTML attribute \"dropzone\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"dropzone\">]\n        let DropZoneDynPred view pred = Client.Attr.DynamicPred \"dropzone\" pred view\n        /// Create an animated HTML attribute \"dropzone\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"dropzone\">]\n        let DropZoneAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"dropzone\" trans view convert.Invoke\n        /// Create an HTML attribute \"enctype\" with the given value.\n        [<Inline; CompiledName \"enctype\"; Macro(typeof<Macros.AttrCreate>, \"enctype\")>]\n        let EncType value = Attr.Create \"enctype\" value\n        /// Create an HTML attribute \"enctype\" with the given reactive value.\n        [<Inline; CompiledName \"enctype\">]\n        let EncTypeDyn view = Client.Attr.Dynamic \"enctype\" view\n        /// `enctype v p` sets an HTML attribute \"enctype\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"enctype\">]\n        let EncTypeDynPred view pred = Client.Attr.DynamicPred \"enctype\" pred view\n        /// Create an animated HTML attribute \"enctype\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"enctype\">]\n        let EncTypeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"enctype\" trans view convert.Invoke\n        /// Create an HTML attribute \"face\" with the given value.\n        [<Inline; CompiledName \"face\"; Macro(typeof<Macros.AttrCreate>, \"face\")>]\n        let Face value = Attr.Create \"face\" value\n        /// Create an HTML attribute \"face\" with the given reactive value.\n        [<Inline; CompiledName \"face\">]\n        let FaceDyn view = Client.Attr.Dynamic \"face\" view\n        /// `face v p` sets an HTML attribute \"face\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"face\">]\n        let FaceDynPred view pred = Client.Attr.DynamicPred \"face\" pred view\n        /// Create an animated HTML attribute \"face\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"face\">]\n        let FaceAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"face\" trans view convert.Invoke\n        /// Create an HTML attribute \"for\" with the given value.\n        [<Inline; CompiledName \"for\"; Macro(typeof<Macros.AttrCreate>, \"for\")>]\n        let For value = Attr.Create \"for\" value\n        /// Create an HTML attribute \"for\" with the given reactive value.\n        [<Inline; CompiledName \"for\">]\n        let ForDyn view = Client.Attr.Dynamic \"for\" view\n        /// `for v p` sets an HTML attribute \"for\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"for\">]\n        let ForDynPred view pred = Client.Attr.DynamicPred \"for\" pred view\n        /// Create an animated HTML attribute \"for\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"for\">]\n        let ForAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"for\" trans view convert.Invoke\n        /// Create an HTML attribute \"form\" with the given value.\n        [<Inline; CompiledName \"form\"; Macro(typeof<Macros.AttrCreate>, \"form\")>]\n        let Form value = Attr.Create \"form\" value\n        /// Create an HTML attribute \"form\" with the given reactive value.\n        [<Inline; CompiledName \"form\">]\n        let FormDyn view = Client.Attr.Dynamic \"form\" view\n        /// `form v p` sets an HTML attribute \"form\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"form\">]\n        let FormDynPred view pred = Client.Attr.DynamicPred \"form\" pred view\n        /// Create an animated HTML attribute \"form\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"form\">]\n        let FormAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"form\" trans view convert.Invoke\n        /// Create an HTML attribute \"formaction\" with the given value.\n        [<Inline; CompiledName \"formaction\"; Macro(typeof<Macros.AttrCreate>, \"formaction\")>]\n        let FormAction value = Attr.Create \"formaction\" value\n        /// Create an HTML attribute \"formaction\" with the given reactive value.\n        [<Inline; CompiledName \"formaction\">]\n        let FormActionDyn view = Client.Attr.Dynamic \"formaction\" view\n        /// `formaction v p` sets an HTML attribute \"formaction\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"formaction\">]\n        let FormActionDynPred view pred = Client.Attr.DynamicPred \"formaction\" pred view\n        /// Create an animated HTML attribute \"formaction\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"formaction\">]\n        let FormActionAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"formaction\" trans view convert.Invoke\n        /// Create an HTML attribute \"formenctype\" with the given value.\n        [<Inline; CompiledName \"formenctype\"; Macro(typeof<Macros.AttrCreate>, \"formenctype\")>]\n        let FormEncType value = Attr.Create \"formenctype\" value\n        /// Create an HTML attribute \"formenctype\" with the given reactive value.\n        [<Inline; CompiledName \"formenctype\">]\n        let FormEncTypeDyn view = Client.Attr.Dynamic \"formenctype\" view\n        /// `formenctype v p` sets an HTML attribute \"formenctype\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"formenctype\">]\n        let FormEncTypeDynPred view pred = Client.Attr.DynamicPred \"formenctype\" pred view\n        /// Create an animated HTML attribute \"formenctype\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"formenctype\">]\n        let FormEncTypeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"formenctype\" trans view convert.Invoke\n        /// Create an HTML attribute \"formmethod\" with the given value.\n        [<Inline; CompiledName \"formmethod\"; Macro(typeof<Macros.AttrCreate>, \"formmethod\")>]\n        let FormMethod value = Attr.Create \"formmethod\" value\n        /// Create an HTML attribute \"formmethod\" with the given reactive value.\n        [<Inline; CompiledName \"formmethod\">]\n        let FormMethodDyn view = Client.Attr.Dynamic \"formmethod\" view\n        /// `formmethod v p` sets an HTML attribute \"formmethod\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"formmethod\">]\n        let FormMethodDynPred view pred = Client.Attr.DynamicPred \"formmethod\" pred view\n        /// Create an animated HTML attribute \"formmethod\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"formmethod\">]\n        let FormMethodAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"formmethod\" trans view convert.Invoke\n        /// Create an HTML attribute \"formnovalidate\" with the given value.\n        [<Inline; CompiledName \"formnovalidate\"; Macro(typeof<Macros.AttrCreate>, \"formnovalidate\")>]\n        let FormNoValidate value = Attr.Create \"formnovalidate\" value\n        /// Create an HTML attribute \"formnovalidate\" with the given reactive value.\n        [<Inline; CompiledName \"formnovalidate\">]\n        let FormNoValidateDyn view = Client.Attr.Dynamic \"formnovalidate\" view\n        /// `formnovalidate v p` sets an HTML attribute \"formnovalidate\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"formnovalidate\">]\n        let FormNoValidateDynPred view pred = Client.Attr.DynamicPred \"formnovalidate\" pred view\n        /// Create an animated HTML attribute \"formnovalidate\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"formnovalidate\">]\n        let FormNoValidateAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"formnovalidate\" trans view convert.Invoke\n        /// Create an HTML attribute \"formtarget\" with the given value.\n        [<Inline; CompiledName \"formtarget\"; Macro(typeof<Macros.AttrCreate>, \"formtarget\")>]\n        let FormTarget value = Attr.Create \"formtarget\" value\n        /// Create an HTML attribute \"formtarget\" with the given reactive value.\n        [<Inline; CompiledName \"formtarget\">]\n        let FormTargetDyn view = Client.Attr.Dynamic \"formtarget\" view\n        /// `formtarget v p` sets an HTML attribute \"formtarget\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"formtarget\">]\n        let FormTargetDynPred view pred = Client.Attr.DynamicPred \"formtarget\" pred view\n        /// Create an animated HTML attribute \"formtarget\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"formtarget\">]\n        let FormTargetAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"formtarget\" trans view convert.Invoke\n        /// Create an HTML attribute \"frame\" with the given value.\n        [<Inline; CompiledName \"frame\"; Macro(typeof<Macros.AttrCreate>, \"frame\")>]\n        let Frame value = Attr.Create \"frame\" value\n        /// Create an HTML attribute \"frame\" with the given reactive value.\n        [<Inline; CompiledName \"frame\">]\n        let FrameDyn view = Client.Attr.Dynamic \"frame\" view\n        /// `frame v p` sets an HTML attribute \"frame\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"frame\">]\n        let FrameDynPred view pred = Client.Attr.DynamicPred \"frame\" pred view\n        /// Create an animated HTML attribute \"frame\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"frame\">]\n        let FrameAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"frame\" trans view convert.Invoke\n        /// Create an HTML attribute \"frameborder\" with the given value.\n        [<Inline; CompiledName \"frameborder\"; Macro(typeof<Macros.AttrCreate>, \"frameborder\")>]\n        let FrameBorder value = Attr.Create \"frameborder\" value\n        /// Create an HTML attribute \"frameborder\" with the given reactive value.\n        [<Inline; CompiledName \"frameborder\">]\n        let FrameBorderDyn view = Client.Attr.Dynamic \"frameborder\" view\n        /// `frameborder v p` sets an HTML attribute \"frameborder\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"frameborder\">]\n        let FrameBorderDynPred view pred = Client.Attr.DynamicPred \"frameborder\" pred view\n        /// Create an animated HTML attribute \"frameborder\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"frameborder\">]\n        let FrameBorderAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"frameborder\" trans view convert.Invoke\n        /// Create an HTML attribute \"headers\" with the given value.\n        [<Inline; CompiledName \"headers\"; Macro(typeof<Macros.AttrCreate>, \"headers\")>]\n        let Headers value = Attr.Create \"headers\" value\n        /// Create an HTML attribute \"headers\" with the given reactive value.\n        [<Inline; CompiledName \"headers\">]\n        let HeadersDyn view = Client.Attr.Dynamic \"headers\" view\n        /// `headers v p` sets an HTML attribute \"headers\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"headers\">]\n        let HeadersDynPred view pred = Client.Attr.DynamicPred \"headers\" pred view\n        /// Create an animated HTML attribute \"headers\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"headers\">]\n        let HeadersAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"headers\" trans view convert.Invoke\n        /// Create an HTML attribute \"height\" with the given value.\n        [<Inline; CompiledName \"height\"; Macro(typeof<Macros.AttrCreate>, \"height\")>]\n        let Height value = Attr.Create \"height\" value\n        /// Create an HTML attribute \"height\" with the given reactive value.\n        [<Inline; CompiledName \"height\">]\n        let HeightDyn view = Client.Attr.Dynamic \"height\" view\n        /// `height v p` sets an HTML attribute \"height\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"height\">]\n        let HeightDynPred view pred = Client.Attr.DynamicPred \"height\" pred view\n        /// Create an animated HTML attribute \"height\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"height\">]\n        let HeightAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"height\" trans view convert.Invoke\n        /// Create an HTML attribute \"hidden\" with the given value.\n        [<Inline; CompiledName \"hidden\"; Macro(typeof<Macros.AttrCreate>, \"hidden\")>]\n        let Hidden value = Attr.Create \"hidden\" value\n        /// Create an HTML attribute \"hidden\" with the given reactive value.\n        [<Inline; CompiledName \"hidden\">]\n        let HiddenDyn view = Client.Attr.Dynamic \"hidden\" view\n        /// `hidden v p` sets an HTML attribute \"hidden\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"hidden\">]\n        let HiddenDynPred view pred = Client.Attr.DynamicPred \"hidden\" pred view\n        /// Create an animated HTML attribute \"hidden\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"hidden\">]\n        let HiddenAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"hidden\" trans view convert.Invoke\n        /// Create an HTML attribute \"high\" with the given value.\n        [<Inline; CompiledName \"high\"; Macro(typeof<Macros.AttrCreate>, \"high\")>]\n        let High value = Attr.Create \"high\" value\n        /// Create an HTML attribute \"high\" with the given reactive value.\n        [<Inline; CompiledName \"high\">]\n        let HighDyn view = Client.Attr.Dynamic \"high\" view\n        /// `high v p` sets an HTML attribute \"high\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"high\">]\n        let HighDynPred view pred = Client.Attr.DynamicPred \"high\" pred view\n        /// Create an animated HTML attribute \"high\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"high\">]\n        let HighAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"high\" trans view convert.Invoke\n        /// Create an HTML attribute \"href\" with the given value.\n        [<Inline; CompiledName \"href\"; Macro(typeof<Macros.AttrCreate>, \"href\")>]\n        let HRef value = Attr.Create \"href\" value\n        /// Create an HTML attribute \"href\" with the given reactive value.\n        [<Inline; CompiledName \"href\">]\n        let HRefDyn view = Client.Attr.Dynamic \"href\" view\n        /// `href v p` sets an HTML attribute \"href\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"href\">]\n        let HRefDynPred view pred = Client.Attr.DynamicPred \"href\" pred view\n        /// Create an animated HTML attribute \"href\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"href\">]\n        let HRefAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"href\" trans view convert.Invoke\n        /// Create an HTML attribute \"hreflang\" with the given value.\n        [<Inline; CompiledName \"hreflang\"; Macro(typeof<Macros.AttrCreate>, \"hreflang\")>]\n        let HRefLang value = Attr.Create \"hreflang\" value\n        /// Create an HTML attribute \"hreflang\" with the given reactive value.\n        [<Inline; CompiledName \"hreflang\">]\n        let HRefLangDyn view = Client.Attr.Dynamic \"hreflang\" view\n        /// `hreflang v p` sets an HTML attribute \"hreflang\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"hreflang\">]\n        let HRefLangDynPred view pred = Client.Attr.DynamicPred \"hreflang\" pred view\n        /// Create an animated HTML attribute \"hreflang\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"hreflang\">]\n        let HRefLangAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"hreflang\" trans view convert.Invoke\n        /// Create an HTML attribute \"hspace\" with the given value.\n        [<Inline; CompiledName \"hspace\"; Macro(typeof<Macros.AttrCreate>, \"hspace\")>]\n        let HSpace value = Attr.Create \"hspace\" value\n        /// Create an HTML attribute \"hspace\" with the given reactive value.\n        [<Inline; CompiledName \"hspace\">]\n        let HSpaceDyn view = Client.Attr.Dynamic \"hspace\" view\n        /// `hspace v p` sets an HTML attribute \"hspace\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"hspace\">]\n        let HSpaceDynPred view pred = Client.Attr.DynamicPred \"hspace\" pred view\n        /// Create an animated HTML attribute \"hspace\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"hspace\">]\n        let HSpaceAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"hspace\" trans view convert.Invoke\n        /// Create an HTML attribute \"http\" with the given value.\n        [<Inline; CompiledName \"http\"; Macro(typeof<Macros.AttrCreate>, \"http\")>]\n        let HttpEquiv value = Attr.Create \"http\" value\n        /// Create an HTML attribute \"http\" with the given reactive value.\n        [<Inline; CompiledName \"http\">]\n        let HttpEquivDyn view = Client.Attr.Dynamic \"http\" view\n        /// `http v p` sets an HTML attribute \"http\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"http\">]\n        let HttpEquivDynPred view pred = Client.Attr.DynamicPred \"http\" pred view\n        /// Create an animated HTML attribute \"http\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"http\">]\n        let HttpEquivAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"http\" trans view convert.Invoke\n        /// Create an HTML attribute \"icon\" with the given value.\n        [<Inline; CompiledName \"icon\"; Macro(typeof<Macros.AttrCreate>, \"icon\")>]\n        let Icon value = Attr.Create \"icon\" value\n        /// Create an HTML attribute \"icon\" with the given reactive value.\n        [<Inline; CompiledName \"icon\">]\n        let IconDyn view = Client.Attr.Dynamic \"icon\" view\n        /// `icon v p` sets an HTML attribute \"icon\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"icon\">]\n        let IconDynPred view pred = Client.Attr.DynamicPred \"icon\" pred view\n        /// Create an animated HTML attribute \"icon\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"icon\">]\n        let IconAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"icon\" trans view convert.Invoke\n        /// Create an HTML attribute \"id\" with the given value.\n        [<Inline; CompiledName \"id\"; Macro(typeof<Macros.AttrCreate>, \"id\")>]\n        let Id value = Attr.Create \"id\" value\n        /// Create an HTML attribute \"id\" with the given reactive value.\n        [<Inline; CompiledName \"id\">]\n        let IdDyn view = Client.Attr.Dynamic \"id\" view\n        /// `id v p` sets an HTML attribute \"id\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"id\">]\n        let IdDynPred view pred = Client.Attr.DynamicPred \"id\" pred view\n        /// Create an animated HTML attribute \"id\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"id\">]\n        let IdAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"id\" trans view convert.Invoke\n        /// Create an HTML attribute \"ismap\" with the given value.\n        [<Inline; CompiledName \"ismap\"; Macro(typeof<Macros.AttrCreate>, \"ismap\")>]\n        let IsMap value = Attr.Create \"ismap\" value\n        /// Create an HTML attribute \"ismap\" with the given reactive value.\n        [<Inline; CompiledName \"ismap\">]\n        let IsMapDyn view = Client.Attr.Dynamic \"ismap\" view\n        /// `ismap v p` sets an HTML attribute \"ismap\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"ismap\">]\n        let IsMapDynPred view pred = Client.Attr.DynamicPred \"ismap\" pred view\n        /// Create an animated HTML attribute \"ismap\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"ismap\">]\n        let IsMapAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"ismap\" trans view convert.Invoke\n        /// Create an HTML attribute \"itemprop\" with the given value.\n        [<Inline; CompiledName \"itemprop\"; Macro(typeof<Macros.AttrCreate>, \"itemprop\")>]\n        let ItemProp value = Attr.Create \"itemprop\" value\n        /// Create an HTML attribute \"itemprop\" with the given reactive value.\n        [<Inline; CompiledName \"itemprop\">]\n        let ItemPropDyn view = Client.Attr.Dynamic \"itemprop\" view\n        /// `itemprop v p` sets an HTML attribute \"itemprop\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"itemprop\">]\n        let ItemPropDynPred view pred = Client.Attr.DynamicPred \"itemprop\" pred view\n        /// Create an animated HTML attribute \"itemprop\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"itemprop\">]\n        let ItemPropAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"itemprop\" trans view convert.Invoke\n        /// Create an HTML attribute \"keytype\" with the given value.\n        [<Inline; CompiledName \"keytype\"; Macro(typeof<Macros.AttrCreate>, \"keytype\")>]\n        let KeyType value = Attr.Create \"keytype\" value\n        /// Create an HTML attribute \"keytype\" with the given reactive value.\n        [<Inline; CompiledName \"keytype\">]\n        let KeyTypeDyn view = Client.Attr.Dynamic \"keytype\" view\n        /// `keytype v p` sets an HTML attribute \"keytype\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"keytype\">]\n        let KeyTypeDynPred view pred = Client.Attr.DynamicPred \"keytype\" pred view\n        /// Create an animated HTML attribute \"keytype\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"keytype\">]\n        let KeyTypeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"keytype\" trans view convert.Invoke\n        /// Create an HTML attribute \"kind\" with the given value.\n        [<Inline; CompiledName \"kind\"; Macro(typeof<Macros.AttrCreate>, \"kind\")>]\n        let Kind value = Attr.Create \"kind\" value\n        /// Create an HTML attribute \"kind\" with the given reactive value.\n        [<Inline; CompiledName \"kind\">]\n        let KindDyn view = Client.Attr.Dynamic \"kind\" view\n        /// `kind v p` sets an HTML attribute \"kind\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"kind\">]\n        let KindDynPred view pred = Client.Attr.DynamicPred \"kind\" pred view\n        /// Create an animated HTML attribute \"kind\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"kind\">]\n        let KindAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"kind\" trans view convert.Invoke\n        /// Create an HTML attribute \"label\" with the given value.\n        [<Inline; CompiledName \"label\"; Macro(typeof<Macros.AttrCreate>, \"label\")>]\n        let Label value = Attr.Create \"label\" value\n        /// Create an HTML attribute \"label\" with the given reactive value.\n        [<Inline; CompiledName \"label\">]\n        let LabelDyn view = Client.Attr.Dynamic \"label\" view\n        /// `label v p` sets an HTML attribute \"label\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"label\">]\n        let LabelDynPred view pred = Client.Attr.DynamicPred \"label\" pred view\n        /// Create an animated HTML attribute \"label\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"label\">]\n        let LabelAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"label\" trans view convert.Invoke\n        /// Create an HTML attribute \"lang\" with the given value.\n        [<Inline; CompiledName \"lang\"; Macro(typeof<Macros.AttrCreate>, \"lang\")>]\n        let Lang value = Attr.Create \"lang\" value\n        /// Create an HTML attribute \"lang\" with the given reactive value.\n        [<Inline; CompiledName \"lang\">]\n        let LangDyn view = Client.Attr.Dynamic \"lang\" view\n        /// `lang v p` sets an HTML attribute \"lang\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"lang\">]\n        let LangDynPred view pred = Client.Attr.DynamicPred \"lang\" pred view\n        /// Create an animated HTML attribute \"lang\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"lang\">]\n        let LangAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"lang\" trans view convert.Invoke\n        /// Create an HTML attribute \"language\" with the given value.\n        [<Inline; CompiledName \"language\"; Macro(typeof<Macros.AttrCreate>, \"language\")>]\n        let Language value = Attr.Create \"language\" value\n        /// Create an HTML attribute \"language\" with the given reactive value.\n        [<Inline; CompiledName \"language\">]\n        let LanguageDyn view = Client.Attr.Dynamic \"language\" view\n        /// `language v p` sets an HTML attribute \"language\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"language\">]\n        let LanguageDynPred view pred = Client.Attr.DynamicPred \"language\" pred view\n        /// Create an animated HTML attribute \"language\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"language\">]\n        let LanguageAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"language\" trans view convert.Invoke\n        /// Create an HTML attribute \"link\" with the given value.\n        [<Inline; CompiledName \"link\"; Macro(typeof<Macros.AttrCreate>, \"link\")>]\n        let Link value = Attr.Create \"link\" value\n        /// Create an HTML attribute \"link\" with the given reactive value.\n        [<Inline; CompiledName \"link\">]\n        let LinkDyn view = Client.Attr.Dynamic \"link\" view\n        /// `link v p` sets an HTML attribute \"link\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"link\">]\n        let LinkDynPred view pred = Client.Attr.DynamicPred \"link\" pred view\n        /// Create an animated HTML attribute \"link\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"link\">]\n        let LinkAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"link\" trans view convert.Invoke\n        /// Create an HTML attribute \"list\" with the given value.\n        [<Inline; CompiledName \"list\"; Macro(typeof<Macros.AttrCreate>, \"list\")>]\n        let List value = Attr.Create \"list\" value\n        /// Create an HTML attribute \"list\" with the given reactive value.\n        [<Inline; CompiledName \"list\">]\n        let ListDyn view = Client.Attr.Dynamic \"list\" view\n        /// `list v p` sets an HTML attribute \"list\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"list\">]\n        let ListDynPred view pred = Client.Attr.DynamicPred \"list\" pred view\n        /// Create an animated HTML attribute \"list\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"list\">]\n        let ListAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"list\" trans view convert.Invoke\n        /// Create an HTML attribute \"longdesc\" with the given value.\n        [<Inline; CompiledName \"longdesc\"; Macro(typeof<Macros.AttrCreate>, \"longdesc\")>]\n        let LongDesc value = Attr.Create \"longdesc\" value\n        /// Create an HTML attribute \"longdesc\" with the given reactive value.\n        [<Inline; CompiledName \"longdesc\">]\n        let LongDescDyn view = Client.Attr.Dynamic \"longdesc\" view\n        /// `longdesc v p` sets an HTML attribute \"longdesc\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"longdesc\">]\n        let LongDescDynPred view pred = Client.Attr.DynamicPred \"longdesc\" pred view\n        /// Create an animated HTML attribute \"longdesc\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"longdesc\">]\n        let LongDescAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"longdesc\" trans view convert.Invoke\n        /// Create an HTML attribute \"loop\" with the given value.\n        [<Inline; CompiledName \"loop\"; Macro(typeof<Macros.AttrCreate>, \"loop\")>]\n        let Loop value = Attr.Create \"loop\" value\n        /// Create an HTML attribute \"loop\" with the given reactive value.\n        [<Inline; CompiledName \"loop\">]\n        let LoopDyn view = Client.Attr.Dynamic \"loop\" view\n        /// `loop v p` sets an HTML attribute \"loop\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"loop\">]\n        let LoopDynPred view pred = Client.Attr.DynamicPred \"loop\" pred view\n        /// Create an animated HTML attribute \"loop\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"loop\">]\n        let LoopAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"loop\" trans view convert.Invoke\n        /// Create an HTML attribute \"low\" with the given value.\n        [<Inline; CompiledName \"low\"; Macro(typeof<Macros.AttrCreate>, \"low\")>]\n        let Low value = Attr.Create \"low\" value\n        /// Create an HTML attribute \"low\" with the given reactive value.\n        [<Inline; CompiledName \"low\">]\n        let LowDyn view = Client.Attr.Dynamic \"low\" view\n        /// `low v p` sets an HTML attribute \"low\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"low\">]\n        let LowDynPred view pred = Client.Attr.DynamicPred \"low\" pred view\n        /// Create an animated HTML attribute \"low\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"low\">]\n        let LowAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"low\" trans view convert.Invoke\n        /// Create an HTML attribute \"manifest\" with the given value.\n        [<Inline; CompiledName \"manifest\"; Macro(typeof<Macros.AttrCreate>, \"manifest\")>]\n        let Manifest value = Attr.Create \"manifest\" value\n        /// Create an HTML attribute \"manifest\" with the given reactive value.\n        [<Inline; CompiledName \"manifest\">]\n        let ManifestDyn view = Client.Attr.Dynamic \"manifest\" view\n        /// `manifest v p` sets an HTML attribute \"manifest\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"manifest\">]\n        let ManifestDynPred view pred = Client.Attr.DynamicPred \"manifest\" pred view\n        /// Create an animated HTML attribute \"manifest\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"manifest\">]\n        let ManifestAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"manifest\" trans view convert.Invoke\n        /// Create an HTML attribute \"marginheight\" with the given value.\n        [<Inline; CompiledName \"marginheight\"; Macro(typeof<Macros.AttrCreate>, \"marginheight\")>]\n        let MarginHeight value = Attr.Create \"marginheight\" value\n        /// Create an HTML attribute \"marginheight\" with the given reactive value.\n        [<Inline; CompiledName \"marginheight\">]\n        let MarginHeightDyn view = Client.Attr.Dynamic \"marginheight\" view\n        /// `marginheight v p` sets an HTML attribute \"marginheight\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"marginheight\">]\n        let MarginHeightDynPred view pred = Client.Attr.DynamicPred \"marginheight\" pred view\n        /// Create an animated HTML attribute \"marginheight\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"marginheight\">]\n        let MarginHeightAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"marginheight\" trans view convert.Invoke\n        /// Create an HTML attribute \"marginwidth\" with the given value.\n        [<Inline; CompiledName \"marginwidth\"; Macro(typeof<Macros.AttrCreate>, \"marginwidth\")>]\n        let MarginWidth value = Attr.Create \"marginwidth\" value\n        /// Create an HTML attribute \"marginwidth\" with the given reactive value.\n        [<Inline; CompiledName \"marginwidth\">]\n        let MarginWidthDyn view = Client.Attr.Dynamic \"marginwidth\" view\n        /// `marginwidth v p` sets an HTML attribute \"marginwidth\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"marginwidth\">]\n        let MarginWidthDynPred view pred = Client.Attr.DynamicPred \"marginwidth\" pred view\n        /// Create an animated HTML attribute \"marginwidth\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"marginwidth\">]\n        let MarginWidthAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"marginwidth\" trans view convert.Invoke\n        /// Create an HTML attribute \"max\" with the given value.\n        [<Inline; CompiledName \"max\"; Macro(typeof<Macros.AttrCreate>, \"max\")>]\n        let Max value = Attr.Create \"max\" value\n        /// Create an HTML attribute \"max\" with the given reactive value.\n        [<Inline; CompiledName \"max\">]\n        let MaxDyn view = Client.Attr.Dynamic \"max\" view\n        /// `max v p` sets an HTML attribute \"max\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"max\">]\n        let MaxDynPred view pred = Client.Attr.DynamicPred \"max\" pred view\n        /// Create an animated HTML attribute \"max\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"max\">]\n        let MaxAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"max\" trans view convert.Invoke\n        /// Create an HTML attribute \"maxlength\" with the given value.\n        [<Inline; CompiledName \"maxlength\"; Macro(typeof<Macros.AttrCreate>, \"maxlength\")>]\n        let MaxLength value = Attr.Create \"maxlength\" value\n        /// Create an HTML attribute \"maxlength\" with the given reactive value.\n        [<Inline; CompiledName \"maxlength\">]\n        let MaxLengthDyn view = Client.Attr.Dynamic \"maxlength\" view\n        /// `maxlength v p` sets an HTML attribute \"maxlength\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"maxlength\">]\n        let MaxLengthDynPred view pred = Client.Attr.DynamicPred \"maxlength\" pred view\n        /// Create an animated HTML attribute \"maxlength\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"maxlength\">]\n        let MaxLengthAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"maxlength\" trans view convert.Invoke\n        /// Create an HTML attribute \"media\" with the given value.\n        [<Inline; CompiledName \"media\"; Macro(typeof<Macros.AttrCreate>, \"media\")>]\n        let Media value = Attr.Create \"media\" value\n        /// Create an HTML attribute \"media\" with the given reactive value.\n        [<Inline; CompiledName \"media\">]\n        let MediaDyn view = Client.Attr.Dynamic \"media\" view\n        /// `media v p` sets an HTML attribute \"media\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"media\">]\n        let MediaDynPred view pred = Client.Attr.DynamicPred \"media\" pred view\n        /// Create an animated HTML attribute \"media\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"media\">]\n        let MediaAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"media\" trans view convert.Invoke\n        /// Create an HTML attribute \"method\" with the given value.\n        [<Inline; CompiledName \"method\"; Macro(typeof<Macros.AttrCreate>, \"method\")>]\n        let Method value = Attr.Create \"method\" value\n        /// Create an HTML attribute \"method\" with the given reactive value.\n        [<Inline; CompiledName \"method\">]\n        let MethodDyn view = Client.Attr.Dynamic \"method\" view\n        /// `method v p` sets an HTML attribute \"method\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"method\">]\n        let MethodDynPred view pred = Client.Attr.DynamicPred \"method\" pred view\n        /// Create an animated HTML attribute \"method\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"method\">]\n        let MethodAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"method\" trans view convert.Invoke\n        /// Create an HTML attribute \"min\" with the given value.\n        [<Inline; CompiledName \"min\"; Macro(typeof<Macros.AttrCreate>, \"min\")>]\n        let Min value = Attr.Create \"min\" value\n        /// Create an HTML attribute \"min\" with the given reactive value.\n        [<Inline; CompiledName \"min\">]\n        let MinDyn view = Client.Attr.Dynamic \"min\" view\n        /// `min v p` sets an HTML attribute \"min\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"min\">]\n        let MinDynPred view pred = Client.Attr.DynamicPred \"min\" pred view\n        /// Create an animated HTML attribute \"min\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"min\">]\n        let MinAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"min\" trans view convert.Invoke\n        /// Create an HTML attribute \"multiple\" with the given value.\n        [<Inline; CompiledName \"multiple\"; Macro(typeof<Macros.AttrCreate>, \"multiple\")>]\n        let Multiple value = Attr.Create \"multiple\" value\n        /// Create an HTML attribute \"multiple\" with the given reactive value.\n        [<Inline; CompiledName \"multiple\">]\n        let MultipleDyn view = Client.Attr.Dynamic \"multiple\" view\n        /// `multiple v p` sets an HTML attribute \"multiple\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"multiple\">]\n        let MultipleDynPred view pred = Client.Attr.DynamicPred \"multiple\" pred view\n        /// Create an animated HTML attribute \"multiple\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"multiple\">]\n        let MultipleAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"multiple\" trans view convert.Invoke\n        /// Create an HTML attribute \"name\" with the given value.\n        [<Inline; CompiledName \"name\"; Macro(typeof<Macros.AttrCreate>, \"name\")>]\n        let Name value = Attr.Create \"name\" value\n        /// Create an HTML attribute \"name\" with the given reactive value.\n        [<Inline; CompiledName \"name\">]\n        let NameDyn view = Client.Attr.Dynamic \"name\" view\n        /// `name v p` sets an HTML attribute \"name\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"name\">]\n        let NameDynPred view pred = Client.Attr.DynamicPred \"name\" pred view\n        /// Create an animated HTML attribute \"name\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"name\">]\n        let NameAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"name\" trans view convert.Invoke\n        /// Create an HTML attribute \"nohref\" with the given value.\n        [<Inline; CompiledName \"nohref\"; Macro(typeof<Macros.AttrCreate>, \"nohref\")>]\n        let NoHRef value = Attr.Create \"nohref\" value\n        /// Create an HTML attribute \"nohref\" with the given reactive value.\n        [<Inline; CompiledName \"nohref\">]\n        let NoHRefDyn view = Client.Attr.Dynamic \"nohref\" view\n        /// `nohref v p` sets an HTML attribute \"nohref\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"nohref\">]\n        let NoHRefDynPred view pred = Client.Attr.DynamicPred \"nohref\" pred view\n        /// Create an animated HTML attribute \"nohref\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"nohref\">]\n        let NoHRefAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"nohref\" trans view convert.Invoke\n        /// Create an HTML attribute \"noresize\" with the given value.\n        [<Inline; CompiledName \"noresize\"; Macro(typeof<Macros.AttrCreate>, \"noresize\")>]\n        let NoResize value = Attr.Create \"noresize\" value\n        /// Create an HTML attribute \"noresize\" with the given reactive value.\n        [<Inline; CompiledName \"noresize\">]\n        let NoResizeDyn view = Client.Attr.Dynamic \"noresize\" view\n        /// `noresize v p` sets an HTML attribute \"noresize\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"noresize\">]\n        let NoResizeDynPred view pred = Client.Attr.DynamicPred \"noresize\" pred view\n        /// Create an animated HTML attribute \"noresize\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"noresize\">]\n        let NoResizeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"noresize\" trans view convert.Invoke\n        /// Create an HTML attribute \"noshade\" with the given value.\n        [<Inline; CompiledName \"noshade\"; Macro(typeof<Macros.AttrCreate>, \"noshade\")>]\n        let NoShade value = Attr.Create \"noshade\" value\n        /// Create an HTML attribute \"noshade\" with the given reactive value.\n        [<Inline; CompiledName \"noshade\">]\n        let NoShadeDyn view = Client.Attr.Dynamic \"noshade\" view\n        /// `noshade v p` sets an HTML attribute \"noshade\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"noshade\">]\n        let NoShadeDynPred view pred = Client.Attr.DynamicPred \"noshade\" pred view\n        /// Create an animated HTML attribute \"noshade\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"noshade\">]\n        let NoShadeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"noshade\" trans view convert.Invoke\n        /// Create an HTML attribute \"novalidate\" with the given value.\n        [<Inline; CompiledName \"novalidate\"; Macro(typeof<Macros.AttrCreate>, \"novalidate\")>]\n        let NoValidate value = Attr.Create \"novalidate\" value\n        /// Create an HTML attribute \"novalidate\" with the given reactive value.\n        [<Inline; CompiledName \"novalidate\">]\n        let NoValidateDyn view = Client.Attr.Dynamic \"novalidate\" view\n        /// `novalidate v p` sets an HTML attribute \"novalidate\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"novalidate\">]\n        let NoValidateDynPred view pred = Client.Attr.DynamicPred \"novalidate\" pred view\n        /// Create an animated HTML attribute \"novalidate\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"novalidate\">]\n        let NoValidateAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"novalidate\" trans view convert.Invoke\n        /// Create an HTML attribute \"nowrap\" with the given value.\n        [<Inline; CompiledName \"nowrap\"; Macro(typeof<Macros.AttrCreate>, \"nowrap\")>]\n        let NoWrap value = Attr.Create \"nowrap\" value\n        /// Create an HTML attribute \"nowrap\" with the given reactive value.\n        [<Inline; CompiledName \"nowrap\">]\n        let NoWrapDyn view = Client.Attr.Dynamic \"nowrap\" view\n        /// `nowrap v p` sets an HTML attribute \"nowrap\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"nowrap\">]\n        let NoWrapDynPred view pred = Client.Attr.DynamicPred \"nowrap\" pred view\n        /// Create an animated HTML attribute \"nowrap\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"nowrap\">]\n        let NoWrapAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"nowrap\" trans view convert.Invoke\n        /// Create an HTML attribute \"object\" with the given value.\n        [<Inline; CompiledName \"object\"; Macro(typeof<Macros.AttrCreate>, \"object\")>]\n        let Object value = Attr.Create \"object\" value\n        /// Create an HTML attribute \"object\" with the given reactive value.\n        [<Inline; CompiledName \"object\">]\n        let ObjectDyn view = Client.Attr.Dynamic \"object\" view\n        /// `object v p` sets an HTML attribute \"object\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"object\">]\n        let ObjectDynPred view pred = Client.Attr.DynamicPred \"object\" pred view\n        /// Create an animated HTML attribute \"object\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"object\">]\n        let ObjectAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"object\" trans view convert.Invoke\n        /// Create an HTML attribute \"open\" with the given value.\n        [<Inline; CompiledName \"open\"; Macro(typeof<Macros.AttrCreate>, \"open\")>]\n        let Open value = Attr.Create \"open\" value\n        /// Create an HTML attribute \"open\" with the given reactive value.\n        [<Inline; CompiledName \"open\">]\n        let OpenDyn view = Client.Attr.Dynamic \"open\" view\n        /// `open v p` sets an HTML attribute \"open\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"open\">]\n        let OpenDynPred view pred = Client.Attr.DynamicPred \"open\" pred view\n        /// Create an animated HTML attribute \"open\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"open\">]\n        let OpenAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"open\" trans view convert.Invoke\n        /// Create an HTML attribute \"optimum\" with the given value.\n        [<Inline; CompiledName \"optimum\"; Macro(typeof<Macros.AttrCreate>, \"optimum\")>]\n        let Optimum value = Attr.Create \"optimum\" value\n        /// Create an HTML attribute \"optimum\" with the given reactive value.\n        [<Inline; CompiledName \"optimum\">]\n        let OptimumDyn view = Client.Attr.Dynamic \"optimum\" view\n        /// `optimum v p` sets an HTML attribute \"optimum\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"optimum\">]\n        let OptimumDynPred view pred = Client.Attr.DynamicPred \"optimum\" pred view\n        /// Create an animated HTML attribute \"optimum\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"optimum\">]\n        let OptimumAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"optimum\" trans view convert.Invoke\n        /// Create an HTML attribute \"pattern\" with the given value.\n        [<Inline; CompiledName \"pattern\"; Macro(typeof<Macros.AttrCreate>, \"pattern\")>]\n        let Pattern value = Attr.Create \"pattern\" value\n        /// Create an HTML attribute \"pattern\" with the given reactive value.\n        [<Inline; CompiledName \"pattern\">]\n        let PatternDyn view = Client.Attr.Dynamic \"pattern\" view\n        /// `pattern v p` sets an HTML attribute \"pattern\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"pattern\">]\n        let PatternDynPred view pred = Client.Attr.DynamicPred \"pattern\" pred view\n        /// Create an animated HTML attribute \"pattern\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"pattern\">]\n        let PatternAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"pattern\" trans view convert.Invoke\n        /// Create an HTML attribute \"ping\" with the given value.\n        [<Inline; CompiledName \"ping\"; Macro(typeof<Macros.AttrCreate>, \"ping\")>]\n        let Ping value = Attr.Create \"ping\" value\n        /// Create an HTML attribute \"ping\" with the given reactive value.\n        [<Inline; CompiledName \"ping\">]\n        let PingDyn view = Client.Attr.Dynamic \"ping\" view\n        /// `ping v p` sets an HTML attribute \"ping\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"ping\">]\n        let PingDynPred view pred = Client.Attr.DynamicPred \"ping\" pred view\n        /// Create an animated HTML attribute \"ping\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"ping\">]\n        let PingAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"ping\" trans view convert.Invoke\n        /// Create an HTML attribute \"placeholder\" with the given value.\n        [<Inline; CompiledName \"placeholder\"; Macro(typeof<Macros.AttrCreate>, \"placeholder\")>]\n        let PlaceHolder value = Attr.Create \"placeholder\" value\n        /// Create an HTML attribute \"placeholder\" with the given reactive value.\n        [<Inline; CompiledName \"placeholder\">]\n        let PlaceHolderDyn view = Client.Attr.Dynamic \"placeholder\" view\n        /// `placeholder v p` sets an HTML attribute \"placeholder\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"placeholder\">]\n        let PlaceHolderDynPred view pred = Client.Attr.DynamicPred \"placeholder\" pred view\n        /// Create an animated HTML attribute \"placeholder\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"placeholder\">]\n        let PlaceHolderAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"placeholder\" trans view convert.Invoke\n        /// Create an HTML attribute \"poster\" with the given value.\n        [<Inline; CompiledName \"poster\"; Macro(typeof<Macros.AttrCreate>, \"poster\")>]\n        let Poster value = Attr.Create \"poster\" value\n        /// Create an HTML attribute \"poster\" with the given reactive value.\n        [<Inline; CompiledName \"poster\">]\n        let PosterDyn view = Client.Attr.Dynamic \"poster\" view\n        /// `poster v p` sets an HTML attribute \"poster\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"poster\">]\n        let PosterDynPred view pred = Client.Attr.DynamicPred \"poster\" pred view\n        /// Create an animated HTML attribute \"poster\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"poster\">]\n        let PosterAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"poster\" trans view convert.Invoke\n        /// Create an HTML attribute \"preload\" with the given value.\n        [<Inline; CompiledName \"preload\"; Macro(typeof<Macros.AttrCreate>, \"preload\")>]\n        let Preload value = Attr.Create \"preload\" value\n        /// Create an HTML attribute \"preload\" with the given reactive value.\n        [<Inline; CompiledName \"preload\">]\n        let PreloadDyn view = Client.Attr.Dynamic \"preload\" view\n        /// `preload v p` sets an HTML attribute \"preload\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"preload\">]\n        let PreloadDynPred view pred = Client.Attr.DynamicPred \"preload\" pred view\n        /// Create an animated HTML attribute \"preload\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"preload\">]\n        let PreloadAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"preload\" trans view convert.Invoke\n        /// Create an HTML attribute \"profile\" with the given value.\n        [<Inline; CompiledName \"profile\"; Macro(typeof<Macros.AttrCreate>, \"profile\")>]\n        let Profile value = Attr.Create \"profile\" value\n        /// Create an HTML attribute \"profile\" with the given reactive value.\n        [<Inline; CompiledName \"profile\">]\n        let ProfileDyn view = Client.Attr.Dynamic \"profile\" view\n        /// `profile v p` sets an HTML attribute \"profile\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"profile\">]\n        let ProfileDynPred view pred = Client.Attr.DynamicPred \"profile\" pred view\n        /// Create an animated HTML attribute \"profile\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"profile\">]\n        let ProfileAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"profile\" trans view convert.Invoke\n        /// Create an HTML attribute \"prompt\" with the given value.\n        [<Inline; CompiledName \"prompt\"; Macro(typeof<Macros.AttrCreate>, \"prompt\")>]\n        let Prompt value = Attr.Create \"prompt\" value\n        /// Create an HTML attribute \"prompt\" with the given reactive value.\n        [<Inline; CompiledName \"prompt\">]\n        let PromptDyn view = Client.Attr.Dynamic \"prompt\" view\n        /// `prompt v p` sets an HTML attribute \"prompt\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"prompt\">]\n        let PromptDynPred view pred = Client.Attr.DynamicPred \"prompt\" pred view\n        /// Create an animated HTML attribute \"prompt\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"prompt\">]\n        let PromptAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"prompt\" trans view convert.Invoke\n        /// Create an HTML attribute \"pubdate\" with the given value.\n        [<Inline; CompiledName \"pubdate\"; Macro(typeof<Macros.AttrCreate>, \"pubdate\")>]\n        let PubDate value = Attr.Create \"pubdate\" value\n        /// Create an HTML attribute \"pubdate\" with the given reactive value.\n        [<Inline; CompiledName \"pubdate\">]\n        let PubDateDyn view = Client.Attr.Dynamic \"pubdate\" view\n        /// `pubdate v p` sets an HTML attribute \"pubdate\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"pubdate\">]\n        let PubDateDynPred view pred = Client.Attr.DynamicPred \"pubdate\" pred view\n        /// Create an animated HTML attribute \"pubdate\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"pubdate\">]\n        let PubDateAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"pubdate\" trans view convert.Invoke\n        /// Create an HTML attribute \"radiogroup\" with the given value.\n        [<Inline; CompiledName \"radiogroup\"; Macro(typeof<Macros.AttrCreate>, \"radiogroup\")>]\n        let RadioGroup value = Attr.Create \"radiogroup\" value\n        /// Create an HTML attribute \"radiogroup\" with the given reactive value.\n        [<Inline; CompiledName \"radiogroup\">]\n        let RadioGroupDyn view = Client.Attr.Dynamic \"radiogroup\" view\n        /// `radiogroup v p` sets an HTML attribute \"radiogroup\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"radiogroup\">]\n        let RadioGroupDynPred view pred = Client.Attr.DynamicPred \"radiogroup\" pred view\n        /// Create an animated HTML attribute \"radiogroup\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"radiogroup\">]\n        let RadioGroupAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"radiogroup\" trans view convert.Invoke\n        /// Create an HTML attribute \"readonly\" with the given value.\n        [<Inline; CompiledName \"readonly\"; Macro(typeof<Macros.AttrCreate>, \"readonly\")>]\n        let ReadOnly value = Attr.Create \"readonly\" value\n        /// Create an HTML attribute \"readonly\" with the given reactive value.\n        [<Inline; CompiledName \"readonly\">]\n        let ReadOnlyDyn view = Client.Attr.Dynamic \"readonly\" view\n        /// `readonly v p` sets an HTML attribute \"readonly\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"readonly\">]\n        let ReadOnlyDynPred view pred = Client.Attr.DynamicPred \"readonly\" pred view\n        /// Create an animated HTML attribute \"readonly\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"readonly\">]\n        let ReadOnlyAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"readonly\" trans view convert.Invoke\n        /// Create an HTML attribute \"rel\" with the given value.\n        [<Inline; CompiledName \"rel\"; Macro(typeof<Macros.AttrCreate>, \"rel\")>]\n        let Rel value = Attr.Create \"rel\" value\n        /// Create an HTML attribute \"rel\" with the given reactive value.\n        [<Inline; CompiledName \"rel\">]\n        let RelDyn view = Client.Attr.Dynamic \"rel\" view\n        /// `rel v p` sets an HTML attribute \"rel\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"rel\">]\n        let RelDynPred view pred = Client.Attr.DynamicPred \"rel\" pred view\n        /// Create an animated HTML attribute \"rel\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"rel\">]\n        let RelAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"rel\" trans view convert.Invoke\n        /// Create an HTML attribute \"required\" with the given value.\n        [<Inline; CompiledName \"required\"; Macro(typeof<Macros.AttrCreate>, \"required\")>]\n        let Required value = Attr.Create \"required\" value\n        /// Create an HTML attribute \"required\" with the given reactive value.\n        [<Inline; CompiledName \"required\">]\n        let RequiredDyn view = Client.Attr.Dynamic \"required\" view\n        /// `required v p` sets an HTML attribute \"required\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"required\">]\n        let RequiredDynPred view pred = Client.Attr.DynamicPred \"required\" pred view\n        /// Create an animated HTML attribute \"required\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"required\">]\n        let RequiredAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"required\" trans view convert.Invoke\n        /// Create an HTML attribute \"rev\" with the given value.\n        [<Inline; CompiledName \"rev\"; Macro(typeof<Macros.AttrCreate>, \"rev\")>]\n        let Rev value = Attr.Create \"rev\" value\n        /// Create an HTML attribute \"rev\" with the given reactive value.\n        [<Inline; CompiledName \"rev\">]\n        let RevDyn view = Client.Attr.Dynamic \"rev\" view\n        /// `rev v p` sets an HTML attribute \"rev\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"rev\">]\n        let RevDynPred view pred = Client.Attr.DynamicPred \"rev\" pred view\n        /// Create an animated HTML attribute \"rev\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"rev\">]\n        let RevAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"rev\" trans view convert.Invoke\n        /// Create an HTML attribute \"reversed\" with the given value.\n        [<Inline; CompiledName \"reversed\"; Macro(typeof<Macros.AttrCreate>, \"reversed\")>]\n        let Reversed value = Attr.Create \"reversed\" value\n        /// Create an HTML attribute \"reversed\" with the given reactive value.\n        [<Inline; CompiledName \"reversed\">]\n        let ReversedDyn view = Client.Attr.Dynamic \"reversed\" view\n        /// `reversed v p` sets an HTML attribute \"reversed\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"reversed\">]\n        let ReversedDynPred view pred = Client.Attr.DynamicPred \"reversed\" pred view\n        /// Create an animated HTML attribute \"reversed\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"reversed\">]\n        let ReversedAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"reversed\" trans view convert.Invoke\n        /// Create an HTML attribute \"rows\" with the given value.\n        [<Inline; CompiledName \"rows\"; Macro(typeof<Macros.AttrCreate>, \"rows\")>]\n        let Rows value = Attr.Create \"rows\" value\n        /// Create an HTML attribute \"rows\" with the given reactive value.\n        [<Inline; CompiledName \"rows\">]\n        let RowsDyn view = Client.Attr.Dynamic \"rows\" view\n        /// `rows v p` sets an HTML attribute \"rows\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"rows\">]\n        let RowsDynPred view pred = Client.Attr.DynamicPred \"rows\" pred view\n        /// Create an animated HTML attribute \"rows\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"rows\">]\n        let RowsAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"rows\" trans view convert.Invoke\n        /// Create an HTML attribute \"rowspan\" with the given value.\n        [<Inline; CompiledName \"rowspan\"; Macro(typeof<Macros.AttrCreate>, \"rowspan\")>]\n        let RowSpan value = Attr.Create \"rowspan\" value\n        /// Create an HTML attribute \"rowspan\" with the given reactive value.\n        [<Inline; CompiledName \"rowspan\">]\n        let RowSpanDyn view = Client.Attr.Dynamic \"rowspan\" view\n        /// `rowspan v p` sets an HTML attribute \"rowspan\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"rowspan\">]\n        let RowSpanDynPred view pred = Client.Attr.DynamicPred \"rowspan\" pred view\n        /// Create an animated HTML attribute \"rowspan\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"rowspan\">]\n        let RowSpanAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"rowspan\" trans view convert.Invoke\n        /// Create an HTML attribute \"rules\" with the given value.\n        [<Inline; CompiledName \"rules\"; Macro(typeof<Macros.AttrCreate>, \"rules\")>]\n        let Rules value = Attr.Create \"rules\" value\n        /// Create an HTML attribute \"rules\" with the given reactive value.\n        [<Inline; CompiledName \"rules\">]\n        let RulesDyn view = Client.Attr.Dynamic \"rules\" view\n        /// `rules v p` sets an HTML attribute \"rules\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"rules\">]\n        let RulesDynPred view pred = Client.Attr.DynamicPred \"rules\" pred view\n        /// Create an animated HTML attribute \"rules\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"rules\">]\n        let RulesAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"rules\" trans view convert.Invoke\n        /// Create an HTML attribute \"sandbox\" with the given value.\n        [<Inline; CompiledName \"sandbox\"; Macro(typeof<Macros.AttrCreate>, \"sandbox\")>]\n        let Sandbox value = Attr.Create \"sandbox\" value\n        /// Create an HTML attribute \"sandbox\" with the given reactive value.\n        [<Inline; CompiledName \"sandbox\">]\n        let SandboxDyn view = Client.Attr.Dynamic \"sandbox\" view\n        /// `sandbox v p` sets an HTML attribute \"sandbox\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"sandbox\">]\n        let SandboxDynPred view pred = Client.Attr.DynamicPred \"sandbox\" pred view\n        /// Create an animated HTML attribute \"sandbox\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"sandbox\">]\n        let SandboxAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"sandbox\" trans view convert.Invoke\n        /// Create an HTML attribute \"scheme\" with the given value.\n        [<Inline; CompiledName \"scheme\"; Macro(typeof<Macros.AttrCreate>, \"scheme\")>]\n        let Scheme value = Attr.Create \"scheme\" value\n        /// Create an HTML attribute \"scheme\" with the given reactive value.\n        [<Inline; CompiledName \"scheme\">]\n        let SchemeDyn view = Client.Attr.Dynamic \"scheme\" view\n        /// `scheme v p` sets an HTML attribute \"scheme\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"scheme\">]\n        let SchemeDynPred view pred = Client.Attr.DynamicPred \"scheme\" pred view\n        /// Create an animated HTML attribute \"scheme\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"scheme\">]\n        let SchemeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"scheme\" trans view convert.Invoke\n        /// Create an HTML attribute \"scope\" with the given value.\n        [<Inline; CompiledName \"scope\"; Macro(typeof<Macros.AttrCreate>, \"scope\")>]\n        let Scope value = Attr.Create \"scope\" value\n        /// Create an HTML attribute \"scope\" with the given reactive value.\n        [<Inline; CompiledName \"scope\">]\n        let ScopeDyn view = Client.Attr.Dynamic \"scope\" view\n        /// `scope v p` sets an HTML attribute \"scope\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"scope\">]\n        let ScopeDynPred view pred = Client.Attr.DynamicPred \"scope\" pred view\n        /// Create an animated HTML attribute \"scope\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"scope\">]\n        let ScopeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"scope\" trans view convert.Invoke\n        /// Create an HTML attribute \"scoped\" with the given value.\n        [<Inline; CompiledName \"scoped\"; Macro(typeof<Macros.AttrCreate>, \"scoped\")>]\n        let Scoped value = Attr.Create \"scoped\" value\n        /// Create an HTML attribute \"scoped\" with the given reactive value.\n        [<Inline; CompiledName \"scoped\">]\n        let ScopedDyn view = Client.Attr.Dynamic \"scoped\" view\n        /// `scoped v p` sets an HTML attribute \"scoped\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"scoped\">]\n        let ScopedDynPred view pred = Client.Attr.DynamicPred \"scoped\" pred view\n        /// Create an animated HTML attribute \"scoped\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"scoped\">]\n        let ScopedAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"scoped\" trans view convert.Invoke\n        /// Create an HTML attribute \"scrolling\" with the given value.\n        [<Inline; CompiledName \"scrolling\"; Macro(typeof<Macros.AttrCreate>, \"scrolling\")>]\n        let Scrolling value = Attr.Create \"scrolling\" value\n        /// Create an HTML attribute \"scrolling\" with the given reactive value.\n        [<Inline; CompiledName \"scrolling\">]\n        let ScrollingDyn view = Client.Attr.Dynamic \"scrolling\" view\n        /// `scrolling v p` sets an HTML attribute \"scrolling\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"scrolling\">]\n        let ScrollingDynPred view pred = Client.Attr.DynamicPred \"scrolling\" pred view\n        /// Create an animated HTML attribute \"scrolling\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"scrolling\">]\n        let ScrollingAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"scrolling\" trans view convert.Invoke\n        /// Create an HTML attribute \"seamless\" with the given value.\n        [<Inline; CompiledName \"seamless\"; Macro(typeof<Macros.AttrCreate>, \"seamless\")>]\n        let Seamless value = Attr.Create \"seamless\" value\n        /// Create an HTML attribute \"seamless\" with the given reactive value.\n        [<Inline; CompiledName \"seamless\">]\n        let SeamlessDyn view = Client.Attr.Dynamic \"seamless\" view\n        /// `seamless v p` sets an HTML attribute \"seamless\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"seamless\">]\n        let SeamlessDynPred view pred = Client.Attr.DynamicPred \"seamless\" pred view\n        /// Create an animated HTML attribute \"seamless\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"seamless\">]\n        let SeamlessAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"seamless\" trans view convert.Invoke\n        /// Create an HTML attribute \"selected\" with the given value.\n        [<Inline; CompiledName \"selected\"; Macro(typeof<Macros.AttrCreate>, \"selected\")>]\n        let Selected value = Attr.Create \"selected\" value\n        /// Create an HTML attribute \"selected\" with the given reactive value.\n        [<Inline; CompiledName \"selected\">]\n        let SelectedDyn view = Client.Attr.Dynamic \"selected\" view\n        /// `selected v p` sets an HTML attribute \"selected\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"selected\">]\n        let SelectedDynPred view pred = Client.Attr.DynamicPred \"selected\" pred view\n        /// Create an animated HTML attribute \"selected\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"selected\">]\n        let SelectedAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"selected\" trans view convert.Invoke\n        /// Create an HTML attribute \"shape\" with the given value.\n        [<Inline; CompiledName \"shape\"; Macro(typeof<Macros.AttrCreate>, \"shape\")>]\n        let Shape value = Attr.Create \"shape\" value\n        /// Create an HTML attribute \"shape\" with the given reactive value.\n        [<Inline; CompiledName \"shape\">]\n        let ShapeDyn view = Client.Attr.Dynamic \"shape\" view\n        /// `shape v p` sets an HTML attribute \"shape\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"shape\">]\n        let ShapeDynPred view pred = Client.Attr.DynamicPred \"shape\" pred view\n        /// Create an animated HTML attribute \"shape\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"shape\">]\n        let ShapeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"shape\" trans view convert.Invoke\n        /// Create an HTML attribute \"size\" with the given value.\n        [<Inline; CompiledName \"size\"; Macro(typeof<Macros.AttrCreate>, \"size\")>]\n        let Size value = Attr.Create \"size\" value\n        /// Create an HTML attribute \"size\" with the given reactive value.\n        [<Inline; CompiledName \"size\">]\n        let SizeDyn view = Client.Attr.Dynamic \"size\" view\n        /// `size v p` sets an HTML attribute \"size\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"size\">]\n        let SizeDynPred view pred = Client.Attr.DynamicPred \"size\" pred view\n        /// Create an animated HTML attribute \"size\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"size\">]\n        let SizeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"size\" trans view convert.Invoke\n        /// Create an HTML attribute \"sizes\" with the given value.\n        [<Inline; CompiledName \"sizes\"; Macro(typeof<Macros.AttrCreate>, \"sizes\")>]\n        let Sizes value = Attr.Create \"sizes\" value\n        /// Create an HTML attribute \"sizes\" with the given reactive value.\n        [<Inline; CompiledName \"sizes\">]\n        let SizesDyn view = Client.Attr.Dynamic \"sizes\" view\n        /// `sizes v p` sets an HTML attribute \"sizes\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"sizes\">]\n        let SizesDynPred view pred = Client.Attr.DynamicPred \"sizes\" pred view\n        /// Create an animated HTML attribute \"sizes\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"sizes\">]\n        let SizesAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"sizes\" trans view convert.Invoke\n        /// Create an HTML attribute \"span\" with the given value.\n        [<Inline; CompiledName \"span\"; Macro(typeof<Macros.AttrCreate>, \"span\")>]\n        let Span value = Attr.Create \"span\" value\n        /// Create an HTML attribute \"span\" with the given reactive value.\n        [<Inline; CompiledName \"span\">]\n        let SpanDyn view = Client.Attr.Dynamic \"span\" view\n        /// `span v p` sets an HTML attribute \"span\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"span\">]\n        let SpanDynPred view pred = Client.Attr.DynamicPred \"span\" pred view\n        /// Create an animated HTML attribute \"span\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"span\">]\n        let SpanAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"span\" trans view convert.Invoke\n        /// Create an HTML attribute \"spellcheck\" with the given value.\n        [<Inline; CompiledName \"spellcheck\"; Macro(typeof<Macros.AttrCreate>, \"spellcheck\")>]\n        let SpellCheck value = Attr.Create \"spellcheck\" value\n        /// Create an HTML attribute \"spellcheck\" with the given reactive value.\n        [<Inline; CompiledName \"spellcheck\">]\n        let SpellCheckDyn view = Client.Attr.Dynamic \"spellcheck\" view\n        /// `spellcheck v p` sets an HTML attribute \"spellcheck\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"spellcheck\">]\n        let SpellCheckDynPred view pred = Client.Attr.DynamicPred \"spellcheck\" pred view\n        /// Create an animated HTML attribute \"spellcheck\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"spellcheck\">]\n        let SpellCheckAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"spellcheck\" trans view convert.Invoke\n        /// Create an HTML attribute \"src\" with the given value.\n        [<Inline; CompiledName \"src\"; Macro(typeof<Macros.AttrCreate>, \"src\")>]\n        let Src value = Attr.Create \"src\" value\n        /// Create an HTML attribute \"src\" with the given reactive value.\n        [<Inline; CompiledName \"src\">]\n        let SrcDyn view = Client.Attr.Dynamic \"src\" view\n        /// `src v p` sets an HTML attribute \"src\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"src\">]\n        let SrcDynPred view pred = Client.Attr.DynamicPred \"src\" pred view\n        /// Create an animated HTML attribute \"src\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"src\">]\n        let SrcAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"src\" trans view convert.Invoke\n        /// Create an HTML attribute \"srcdoc\" with the given value.\n        [<Inline; CompiledName \"srcdoc\"; Macro(typeof<Macros.AttrCreate>, \"srcdoc\")>]\n        let SrcDoc value = Attr.Create \"srcdoc\" value\n        /// Create an HTML attribute \"srcdoc\" with the given reactive value.\n        [<Inline; CompiledName \"srcdoc\">]\n        let SrcDocDyn view = Client.Attr.Dynamic \"srcdoc\" view\n        /// `srcdoc v p` sets an HTML attribute \"srcdoc\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"srcdoc\">]\n        let SrcDocDynPred view pred = Client.Attr.DynamicPred \"srcdoc\" pred view\n        /// Create an animated HTML attribute \"srcdoc\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"srcdoc\">]\n        let SrcDocAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"srcdoc\" trans view convert.Invoke\n        /// Create an HTML attribute \"srclang\" with the given value.\n        [<Inline; CompiledName \"srclang\"; Macro(typeof<Macros.AttrCreate>, \"srclang\")>]\n        let SrcLang value = Attr.Create \"srclang\" value\n        /// Create an HTML attribute \"srclang\" with the given reactive value.\n        [<Inline; CompiledName \"srclang\">]\n        let SrcLangDyn view = Client.Attr.Dynamic \"srclang\" view\n        /// `srclang v p` sets an HTML attribute \"srclang\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"srclang\">]\n        let SrcLangDynPred view pred = Client.Attr.DynamicPred \"srclang\" pred view\n        /// Create an animated HTML attribute \"srclang\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"srclang\">]\n        let SrcLangAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"srclang\" trans view convert.Invoke\n        /// Create an HTML attribute \"standby\" with the given value.\n        [<Inline; CompiledName \"standby\"; Macro(typeof<Macros.AttrCreate>, \"standby\")>]\n        let StandBy value = Attr.Create \"standby\" value\n        /// Create an HTML attribute \"standby\" with the given reactive value.\n        [<Inline; CompiledName \"standby\">]\n        let StandByDyn view = Client.Attr.Dynamic \"standby\" view\n        /// `standby v p` sets an HTML attribute \"standby\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"standby\">]\n        let StandByDynPred view pred = Client.Attr.DynamicPred \"standby\" pred view\n        /// Create an animated HTML attribute \"standby\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"standby\">]\n        let StandByAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"standby\" trans view convert.Invoke\n        /// Create an HTML attribute \"start\" with the given value.\n        [<Inline; CompiledName \"start\"; Macro(typeof<Macros.AttrCreate>, \"start\")>]\n        let Start value = Attr.Create \"start\" value\n        /// Create an HTML attribute \"start\" with the given reactive value.\n        [<Inline; CompiledName \"start\">]\n        let StartDyn view = Client.Attr.Dynamic \"start\" view\n        /// `start v p` sets an HTML attribute \"start\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"start\">]\n        let StartDynPred view pred = Client.Attr.DynamicPred \"start\" pred view\n        /// Create an animated HTML attribute \"start\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"start\">]\n        let StartAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"start\" trans view convert.Invoke\n        /// Create an HTML attribute \"step\" with the given value.\n        [<Inline; CompiledName \"step\"; Macro(typeof<Macros.AttrCreate>, \"step\")>]\n        let Step value = Attr.Create \"step\" value\n        /// Create an HTML attribute \"step\" with the given reactive value.\n        [<Inline; CompiledName \"step\">]\n        let StepDyn view = Client.Attr.Dynamic \"step\" view\n        /// `step v p` sets an HTML attribute \"step\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"step\">]\n        let StepDynPred view pred = Client.Attr.DynamicPred \"step\" pred view\n        /// Create an animated HTML attribute \"step\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"step\">]\n        let StepAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"step\" trans view convert.Invoke\n        /// Create an HTML attribute \"style\" with the given value.\n        [<Inline; CompiledName \"style\"; Macro(typeof<Macros.AttrCreate>, \"style\")>]\n        let Style value = Attr.Create \"style\" value\n        /// Create an HTML attribute \"style\" with the given reactive value.\n        [<Inline; CompiledName \"style\">]\n        let StyleDyn view = Client.Attr.Dynamic \"style\" view\n        /// `style v p` sets an HTML attribute \"style\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"style\">]\n        let StyleDynPred view pred = Client.Attr.DynamicPred \"style\" pred view\n        /// Create an animated HTML attribute \"style\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"style\">]\n        let StyleAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"style\" trans view convert.Invoke\n        /// Create an HTML attribute \"subject\" with the given value.\n        [<Inline; CompiledName \"subject\"; Macro(typeof<Macros.AttrCreate>, \"subject\")>]\n        let Subject value = Attr.Create \"subject\" value\n        /// Create an HTML attribute \"subject\" with the given reactive value.\n        [<Inline; CompiledName \"subject\">]\n        let SubjectDyn view = Client.Attr.Dynamic \"subject\" view\n        /// `subject v p` sets an HTML attribute \"subject\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"subject\">]\n        let SubjectDynPred view pred = Client.Attr.DynamicPred \"subject\" pred view\n        /// Create an animated HTML attribute \"subject\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"subject\">]\n        let SubjectAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"subject\" trans view convert.Invoke\n        /// Create an HTML attribute \"summary\" with the given value.\n        [<Inline; CompiledName \"summary\"; Macro(typeof<Macros.AttrCreate>, \"summary\")>]\n        let Summary value = Attr.Create \"summary\" value\n        /// Create an HTML attribute \"summary\" with the given reactive value.\n        [<Inline; CompiledName \"summary\">]\n        let SummaryDyn view = Client.Attr.Dynamic \"summary\" view\n        /// `summary v p` sets an HTML attribute \"summary\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"summary\">]\n        let SummaryDynPred view pred = Client.Attr.DynamicPred \"summary\" pred view\n        /// Create an animated HTML attribute \"summary\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"summary\">]\n        let SummaryAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"summary\" trans view convert.Invoke\n        /// Create an HTML attribute \"tabindex\" with the given value.\n        [<Inline; CompiledName \"tabindex\"; Macro(typeof<Macros.AttrCreate>, \"tabindex\")>]\n        let TabIndex value = Attr.Create \"tabindex\" value\n        /// Create an HTML attribute \"tabindex\" with the given reactive value.\n        [<Inline; CompiledName \"tabindex\">]\n        let TabIndexDyn view = Client.Attr.Dynamic \"tabindex\" view\n        /// `tabindex v p` sets an HTML attribute \"tabindex\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"tabindex\">]\n        let TabIndexDynPred view pred = Client.Attr.DynamicPred \"tabindex\" pred view\n        /// Create an animated HTML attribute \"tabindex\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"tabindex\">]\n        let TabIndexAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"tabindex\" trans view convert.Invoke\n        /// Create an HTML attribute \"target\" with the given value.\n        [<Inline; CompiledName \"target\"; Macro(typeof<Macros.AttrCreate>, \"target\")>]\n        let Target value = Attr.Create \"target\" value\n        /// Create an HTML attribute \"target\" with the given reactive value.\n        [<Inline; CompiledName \"target\">]\n        let TargetDyn view = Client.Attr.Dynamic \"target\" view\n        /// `target v p` sets an HTML attribute \"target\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"target\">]\n        let TargetDynPred view pred = Client.Attr.DynamicPred \"target\" pred view\n        /// Create an animated HTML attribute \"target\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"target\">]\n        let TargetAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"target\" trans view convert.Invoke\n        /// Create an HTML attribute \"text\" with the given value.\n        [<Inline; CompiledName \"text\"; Macro(typeof<Macros.AttrCreate>, \"text\")>]\n        let Text value = Attr.Create \"text\" value\n        /// Create an HTML attribute \"text\" with the given reactive value.\n        [<Inline; CompiledName \"text\">]\n        let TextDyn view = Client.Attr.Dynamic \"text\" view\n        /// `text v p` sets an HTML attribute \"text\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"text\">]\n        let TextDynPred view pred = Client.Attr.DynamicPred \"text\" pred view\n        /// Create an animated HTML attribute \"text\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"text\">]\n        let TextAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"text\" trans view convert.Invoke\n        /// Create an HTML attribute \"title\" with the given value.\n        [<Inline; CompiledName \"title\"; Macro(typeof<Macros.AttrCreate>, \"title\")>]\n        let Title value = Attr.Create \"title\" value\n        /// Create an HTML attribute \"title\" with the given reactive value.\n        [<Inline; CompiledName \"title\">]\n        let TitleDyn view = Client.Attr.Dynamic \"title\" view\n        /// `title v p` sets an HTML attribute \"title\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"title\">]\n        let TitleDynPred view pred = Client.Attr.DynamicPred \"title\" pred view\n        /// Create an animated HTML attribute \"title\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"title\">]\n        let TitleAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"title\" trans view convert.Invoke\n        /// Create an HTML attribute \"type\" with the given value.\n        [<Inline; CompiledName \"type\"; Macro(typeof<Macros.AttrCreate>, \"type\")>]\n        let Type value = Attr.Create \"type\" value\n        /// Create an HTML attribute \"type\" with the given reactive value.\n        [<Inline; CompiledName \"type\">]\n        let TypeDyn view = Client.Attr.Dynamic \"type\" view\n        /// `type v p` sets an HTML attribute \"type\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"type\">]\n        let TypeDynPred view pred = Client.Attr.DynamicPred \"type\" pred view\n        /// Create an animated HTML attribute \"type\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"type\">]\n        let TypeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"type\" trans view convert.Invoke\n        /// Create an HTML attribute \"usemap\" with the given value.\n        [<Inline; CompiledName \"usemap\"; Macro(typeof<Macros.AttrCreate>, \"usemap\")>]\n        let UseMap value = Attr.Create \"usemap\" value\n        /// Create an HTML attribute \"usemap\" with the given reactive value.\n        [<Inline; CompiledName \"usemap\">]\n        let UseMapDyn view = Client.Attr.Dynamic \"usemap\" view\n        /// `usemap v p` sets an HTML attribute \"usemap\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"usemap\">]\n        let UseMapDynPred view pred = Client.Attr.DynamicPred \"usemap\" pred view\n        /// Create an animated HTML attribute \"usemap\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"usemap\">]\n        let UseMapAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"usemap\" trans view convert.Invoke\n        /// Create an HTML attribute \"valign\" with the given value.\n        [<Inline; CompiledName \"valign\"; Macro(typeof<Macros.AttrCreate>, \"valign\")>]\n        let VAlign value = Attr.Create \"valign\" value\n        /// Create an HTML attribute \"valign\" with the given reactive value.\n        [<Inline; CompiledName \"valign\">]\n        let VAlignDyn view = Client.Attr.Dynamic \"valign\" view\n        /// `valign v p` sets an HTML attribute \"valign\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"valign\">]\n        let VAlignDynPred view pred = Client.Attr.DynamicPred \"valign\" pred view\n        /// Create an animated HTML attribute \"valign\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"valign\">]\n        let VAlignAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"valign\" trans view convert.Invoke\n        /// Create an HTML attribute \"value\" with the given value.\n        [<Inline; CompiledName \"value\"; Macro(typeof<Macros.AttrCreate>, \"value\")>]\n        let Value value = Attr.Create \"value\" value\n        /// Create an HTML attribute \"value\" with the given reactive value.\n        [<Inline; CompiledName \"value\">]\n        let ValueDyn view = Client.Attr.Dynamic \"value\" view\n        /// `value v p` sets an HTML attribute \"value\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"value\">]\n        let ValueDynPred view pred = Client.Attr.DynamicPred \"value\" pred view\n        /// Create an animated HTML attribute \"value\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"value\">]\n        let ValueAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"value\" trans view convert.Invoke\n        /// Create an HTML attribute \"valuetype\" with the given value.\n        [<Inline; CompiledName \"valuetype\"; Macro(typeof<Macros.AttrCreate>, \"valuetype\")>]\n        let ValueType value = Attr.Create \"valuetype\" value\n        /// Create an HTML attribute \"valuetype\" with the given reactive value.\n        [<Inline; CompiledName \"valuetype\">]\n        let ValueTypeDyn view = Client.Attr.Dynamic \"valuetype\" view\n        /// `valuetype v p` sets an HTML attribute \"valuetype\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"valuetype\">]\n        let ValueTypeDynPred view pred = Client.Attr.DynamicPred \"valuetype\" pred view\n        /// Create an animated HTML attribute \"valuetype\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"valuetype\">]\n        let ValueTypeAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"valuetype\" trans view convert.Invoke\n        /// Create an HTML attribute \"version\" with the given value.\n        [<Inline; CompiledName \"version\"; Macro(typeof<Macros.AttrCreate>, \"version\")>]\n        let Version value = Attr.Create \"version\" value\n        /// Create an HTML attribute \"version\" with the given reactive value.\n        [<Inline; CompiledName \"version\">]\n        let VersionDyn view = Client.Attr.Dynamic \"version\" view\n        /// `version v p` sets an HTML attribute \"version\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"version\">]\n        let VersionDynPred view pred = Client.Attr.DynamicPred \"version\" pred view\n        /// Create an animated HTML attribute \"version\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"version\">]\n        let VersionAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"version\" trans view convert.Invoke\n        /// Create an HTML attribute \"vlink\" with the given value.\n        [<Inline; CompiledName \"vlink\"; Macro(typeof<Macros.AttrCreate>, \"vlink\")>]\n        let VLink value = Attr.Create \"vlink\" value\n        /// Create an HTML attribute \"vlink\" with the given reactive value.\n        [<Inline; CompiledName \"vlink\">]\n        let VLinkDyn view = Client.Attr.Dynamic \"vlink\" view\n        /// `vlink v p` sets an HTML attribute \"vlink\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"vlink\">]\n        let VLinkDynPred view pred = Client.Attr.DynamicPred \"vlink\" pred view\n        /// Create an animated HTML attribute \"vlink\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"vlink\">]\n        let VLinkAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"vlink\" trans view convert.Invoke\n        /// Create an HTML attribute \"vspace\" with the given value.\n        [<Inline; CompiledName \"vspace\"; Macro(typeof<Macros.AttrCreate>, \"vspace\")>]\n        let VSpace value = Attr.Create \"vspace\" value\n        /// Create an HTML attribute \"vspace\" with the given reactive value.\n        [<Inline; CompiledName \"vspace\">]\n        let VSpaceDyn view = Client.Attr.Dynamic \"vspace\" view\n        /// `vspace v p` sets an HTML attribute \"vspace\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"vspace\">]\n        let VSpaceDynPred view pred = Client.Attr.DynamicPred \"vspace\" pred view\n        /// Create an animated HTML attribute \"vspace\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"vspace\">]\n        let VSpaceAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"vspace\" trans view convert.Invoke\n        /// Create an HTML attribute \"width\" with the given value.\n        [<Inline; CompiledName \"width\"; Macro(typeof<Macros.AttrCreate>, \"width\")>]\n        let Width value = Attr.Create \"width\" value\n        /// Create an HTML attribute \"width\" with the given reactive value.\n        [<Inline; CompiledName \"width\">]\n        let WidthDyn view = Client.Attr.Dynamic \"width\" view\n        /// `width v p` sets an HTML attribute \"width\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"width\">]\n        let WidthDynPred view pred = Client.Attr.DynamicPred \"width\" pred view\n        /// Create an animated HTML attribute \"width\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"width\">]\n        let WidthAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"width\" trans view convert.Invoke\n        /// Create an HTML attribute \"wrap\" with the given value.\n        [<Inline; CompiledName \"wrap\"; Macro(typeof<Macros.AttrCreate>, \"wrap\")>]\n        let Wrap value = Attr.Create \"wrap\" value\n        /// Create an HTML attribute \"wrap\" with the given reactive value.\n        [<Inline; CompiledName \"wrap\">]\n        let WrapDyn view = Client.Attr.Dynamic \"wrap\" view\n        /// `wrap v p` sets an HTML attribute \"wrap\" with reactive value v when p is true, and unsets it when p is false.\n        [<Inline; CompiledName \"wrap\">]\n        let WrapDynPred view pred = Client.Attr.DynamicPred \"wrap\" pred view\n        /// Create an animated HTML attribute \"wrap\" whose value is computed from the given reactive view.\n        [<Inline; CompiledName \"wrap\">]\n        let WrapAnim view (convert: Converter<_,_>) trans = Client.Attr.Animated \"wrap\" trans view convert.Invoke\n        // }}\n\n    module on =\n\n        /// Adds a callback to be called after the element has been inserted in the DOM.\n        /// The callback is guaranteed to be called only once, even if the element is moved or removed and reinserted.\n        [<Inline>]\n        let afterRender (f: Action<Dom.Element>) = Client.Attr.OnAfterRender (FSharpConvert.Fun f)\n\n        /// Adds a callback to be called every time the given view receives an updated value,\n        /// iff the element is currently in the DOM.\n        [<Inline>]\n        let viewUpdate (v: View<'T>) (f: Action<Dom.Element, 'T>) = Client.Attr.DynamicCustom (FSharpConvert.Fun f) v\n\n        // {{ event\n        /// Create a handler for the event \"abort\".\n        [<Inline; CompiledName \"abort\">]\n        let Abort_ (f: System.Action<Dom.Element, Dom.UIEvent>) = Client.Attr.Handler \"abort\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"abort\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"abort\">]\n        let AbortView (view: View<'T>) (f: System.Action<Dom.Element, Dom.UIEvent, 'T>) = Client.Attr.HandlerView \"abort\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"afterprint\".\n        [<Inline; CompiledName \"afterPrint\">]\n        let AfterPrint_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"afterprint\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"afterprint\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"afterPrint\">]\n        let AfterPrintView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"afterprint\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"animationend\".\n        [<Inline; CompiledName \"animationEnd\">]\n        let AnimationEnd_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"animationend\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"animationend\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"animationEnd\">]\n        let AnimationEndView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"animationend\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"animationiteration\".\n        [<Inline; CompiledName \"animationIteration\">]\n        let AnimationIteration_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"animationiteration\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"animationiteration\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"animationIteration\">]\n        let AnimationIterationView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"animationiteration\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"animationstart\".\n        [<Inline; CompiledName \"animationStart\">]\n        let AnimationStart_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"animationstart\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"animationstart\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"animationStart\">]\n        let AnimationStartView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"animationstart\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"audioprocess\".\n        [<Inline; CompiledName \"audioProcess\">]\n        let AudioProcess_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"audioprocess\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"audioprocess\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"audioProcess\">]\n        let AudioProcessView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"audioprocess\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"beforeprint\".\n        [<Inline; CompiledName \"beforePrint\">]\n        let BeforePrint_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"beforeprint\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"beforeprint\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"beforePrint\">]\n        let BeforePrintView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"beforeprint\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"beforeunload\".\n        [<Inline; CompiledName \"beforeUnload\">]\n        let BeforeUnload_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"beforeunload\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"beforeunload\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"beforeUnload\">]\n        let BeforeUnloadView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"beforeunload\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"beginEvent\".\n        [<Inline; CompiledName \"beginEvent\">]\n        let BeginEvent_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"beginEvent\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"beginEvent\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"beginEvent\">]\n        let BeginEventView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"beginEvent\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"blocked\".\n        [<Inline; CompiledName \"blocked\">]\n        let Blocked_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"blocked\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"blocked\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"blocked\">]\n        let BlockedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"blocked\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"blur\".\n        [<Inline; CompiledName \"blur\">]\n        let Blur_ (f: System.Action<Dom.Element, Dom.FocusEvent>) = Client.Attr.Handler \"blur\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"blur\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"blur\">]\n        let BlurView (view: View<'T>) (f: System.Action<Dom.Element, Dom.FocusEvent, 'T>) = Client.Attr.HandlerView \"blur\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"cached\".\n        [<Inline; CompiledName \"cached\">]\n        let Cached_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"cached\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"cached\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"cached\">]\n        let CachedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"cached\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"canplay\".\n        [<Inline; CompiledName \"canPlay\">]\n        let CanPlay_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"canplay\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"canplay\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"canPlay\">]\n        let CanPlayView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"canplay\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"canplaythrough\".\n        [<Inline; CompiledName \"canPlayThrough\">]\n        let CanPlayThrough_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"canplaythrough\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"canplaythrough\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"canPlayThrough\">]\n        let CanPlayThroughView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"canplaythrough\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"change\".\n        [<Inline; CompiledName \"change\">]\n        let Change_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"change\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"change\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"change\">]\n        let ChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"change\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"chargingchange\".\n        [<Inline; CompiledName \"chargingChange\">]\n        let ChargingChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"chargingchange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"chargingchange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"chargingChange\">]\n        let ChargingChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"chargingchange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"chargingtimechange\".\n        [<Inline; CompiledName \"chargingTimeChange\">]\n        let ChargingTimeChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"chargingtimechange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"chargingtimechange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"chargingTimeChange\">]\n        let ChargingTimeChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"chargingtimechange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"checking\".\n        [<Inline; CompiledName \"checking\">]\n        let Checking_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"checking\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"checking\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"checking\">]\n        let CheckingView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"checking\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"click\".\n        [<Inline; CompiledName \"click\">]\n        let Click_ (f: System.Action<Dom.Element, Dom.MouseEvent>) = Client.Attr.Handler \"click\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"click\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"click\">]\n        let ClickView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MouseEvent, 'T>) = Client.Attr.HandlerView \"click\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"close\".\n        [<Inline; CompiledName \"close\">]\n        let Close_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"close\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"close\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"close\">]\n        let CloseView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"close\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"complete\".\n        [<Inline; CompiledName \"complete\">]\n        let Complete_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"complete\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"complete\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"complete\">]\n        let CompleteView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"complete\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"compositionend\".\n        [<Inline; CompiledName \"compositionEnd\">]\n        let CompositionEnd_ (f: System.Action<Dom.Element, Dom.CompositionEvent>) = Client.Attr.Handler \"compositionend\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"compositionend\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"compositionEnd\">]\n        let CompositionEndView (view: View<'T>) (f: System.Action<Dom.Element, Dom.CompositionEvent, 'T>) = Client.Attr.HandlerView \"compositionend\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"compositionstart\".\n        [<Inline; CompiledName \"compositionStart\">]\n        let CompositionStart_ (f: System.Action<Dom.Element, Dom.CompositionEvent>) = Client.Attr.Handler \"compositionstart\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"compositionstart\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"compositionStart\">]\n        let CompositionStartView (view: View<'T>) (f: System.Action<Dom.Element, Dom.CompositionEvent, 'T>) = Client.Attr.HandlerView \"compositionstart\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"compositionupdate\".\n        [<Inline; CompiledName \"compositionUpdate\">]\n        let CompositionUpdate_ (f: System.Action<Dom.Element, Dom.CompositionEvent>) = Client.Attr.Handler \"compositionupdate\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"compositionupdate\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"compositionUpdate\">]\n        let CompositionUpdateView (view: View<'T>) (f: System.Action<Dom.Element, Dom.CompositionEvent, 'T>) = Client.Attr.HandlerView \"compositionupdate\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"contextmenu\".\n        [<Inline; CompiledName \"contextMenu\">]\n        let ContextMenu_ (f: System.Action<Dom.Element, Dom.MouseEvent>) = Client.Attr.Handler \"contextmenu\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"contextmenu\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"contextMenu\">]\n        let ContextMenuView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MouseEvent, 'T>) = Client.Attr.HandlerView \"contextmenu\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"copy\".\n        [<Inline; CompiledName \"copy\">]\n        let Copy_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"copy\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"copy\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"copy\">]\n        let CopyView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"copy\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"cut\".\n        [<Inline; CompiledName \"cut\">]\n        let Cut_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"cut\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"cut\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"cut\">]\n        let CutView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"cut\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dblclick\".\n        [<Inline; CompiledName \"dblClick\">]\n        let DblClick_ (f: System.Action<Dom.Element, Dom.MouseEvent>) = Client.Attr.Handler \"dblclick\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dblclick\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"dblClick\">]\n        let DblClickView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MouseEvent, 'T>) = Client.Attr.HandlerView \"dblclick\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"devicelight\".\n        [<Inline; CompiledName \"deviceLight\">]\n        let DeviceLight_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"devicelight\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"devicelight\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"deviceLight\">]\n        let DeviceLightView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"devicelight\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"devicemotion\".\n        [<Inline; CompiledName \"deviceMotion\">]\n        let DeviceMotion_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"devicemotion\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"devicemotion\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"deviceMotion\">]\n        let DeviceMotionView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"devicemotion\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"deviceorientation\".\n        [<Inline; CompiledName \"deviceOrientation\">]\n        let DeviceOrientation_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"deviceorientation\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"deviceorientation\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"deviceOrientation\">]\n        let DeviceOrientationView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"deviceorientation\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"deviceproximity\".\n        [<Inline; CompiledName \"deviceProximity\">]\n        let DeviceProximity_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"deviceproximity\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"deviceproximity\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"deviceProximity\">]\n        let DeviceProximityView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"deviceproximity\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dischargingtimechange\".\n        [<Inline; CompiledName \"dischargingTimeChange\">]\n        let DischargingTimeChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"dischargingtimechange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dischargingtimechange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"dischargingTimeChange\">]\n        let DischargingTimeChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"dischargingtimechange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMActivate\".\n        [<Inline; CompiledName \"DOMActivate\">]\n        let DOMActivate_ (f: System.Action<Dom.Element, Dom.UIEvent>) = Client.Attr.Handler \"DOMActivate\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMActivate\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"DOMActivate\">]\n        let DOMActivateView (view: View<'T>) (f: System.Action<Dom.Element, Dom.UIEvent, 'T>) = Client.Attr.HandlerView \"DOMActivate\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMAttributeNameChanged\".\n        [<Inline; CompiledName \"DOMAttributeNameChanged\">]\n        let DOMAttributeNameChanged_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"DOMAttributeNameChanged\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMAttributeNameChanged\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"DOMAttributeNameChanged\">]\n        let DOMAttributeNameChangedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"DOMAttributeNameChanged\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMAttrModified\".\n        [<Inline; CompiledName \"DOMAttrModified\">]\n        let DOMAttrModified_ (f: System.Action<Dom.Element, Dom.MutationEvent>) = Client.Attr.Handler \"DOMAttrModified\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMAttrModified\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"DOMAttrModified\">]\n        let DOMAttrModifiedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MutationEvent, 'T>) = Client.Attr.HandlerView \"DOMAttrModified\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMCharacterDataModified\".\n        [<Inline; CompiledName \"DOMCharacterDataModified\">]\n        let DOMCharacterDataModified_ (f: System.Action<Dom.Element, Dom.MutationEvent>) = Client.Attr.Handler \"DOMCharacterDataModified\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMCharacterDataModified\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"DOMCharacterDataModified\">]\n        let DOMCharacterDataModifiedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MutationEvent, 'T>) = Client.Attr.HandlerView \"DOMCharacterDataModified\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMContentLoaded\".\n        [<Inline; CompiledName \"DOMContentLoaded\">]\n        let DOMContentLoaded_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"DOMContentLoaded\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMContentLoaded\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"DOMContentLoaded\">]\n        let DOMContentLoadedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"DOMContentLoaded\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMElementNameChanged\".\n        [<Inline; CompiledName \"DOMElementNameChanged\">]\n        let DOMElementNameChanged_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"DOMElementNameChanged\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMElementNameChanged\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"DOMElementNameChanged\">]\n        let DOMElementNameChangedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"DOMElementNameChanged\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMNodeInserted\".\n        [<Inline; CompiledName \"DOMNodeInserted\">]\n        let DOMNodeInserted_ (f: System.Action<Dom.Element, Dom.MutationEvent>) = Client.Attr.Handler \"DOMNodeInserted\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMNodeInserted\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"DOMNodeInserted\">]\n        let DOMNodeInsertedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MutationEvent, 'T>) = Client.Attr.HandlerView \"DOMNodeInserted\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMNodeInsertedIntoDocument\".\n        [<Inline; CompiledName \"DOMNodeInsertedIntoDocument\">]\n        let DOMNodeInsertedIntoDocument_ (f: System.Action<Dom.Element, Dom.MutationEvent>) = Client.Attr.Handler \"DOMNodeInsertedIntoDocument\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMNodeInsertedIntoDocument\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"DOMNodeInsertedIntoDocument\">]\n        let DOMNodeInsertedIntoDocumentView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MutationEvent, 'T>) = Client.Attr.HandlerView \"DOMNodeInsertedIntoDocument\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMNodeRemoved\".\n        [<Inline; CompiledName \"DOMNodeRemoved\">]\n        let DOMNodeRemoved_ (f: System.Action<Dom.Element, Dom.MutationEvent>) = Client.Attr.Handler \"DOMNodeRemoved\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMNodeRemoved\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"DOMNodeRemoved\">]\n        let DOMNodeRemovedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MutationEvent, 'T>) = Client.Attr.HandlerView \"DOMNodeRemoved\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMNodeRemovedFromDocument\".\n        [<Inline; CompiledName \"DOMNodeRemovedFromDocument\">]\n        let DOMNodeRemovedFromDocument_ (f: System.Action<Dom.Element, Dom.MutationEvent>) = Client.Attr.Handler \"DOMNodeRemovedFromDocument\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMNodeRemovedFromDocument\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"DOMNodeRemovedFromDocument\">]\n        let DOMNodeRemovedFromDocumentView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MutationEvent, 'T>) = Client.Attr.HandlerView \"DOMNodeRemovedFromDocument\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMSubtreeModified\".\n        [<Inline; CompiledName \"DOMSubtreeModified\">]\n        let DOMSubtreeModified_ (f: System.Action<Dom.Element, Dom.MutationEvent>) = Client.Attr.Handler \"DOMSubtreeModified\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"DOMSubtreeModified\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"DOMSubtreeModified\">]\n        let DOMSubtreeModifiedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MutationEvent, 'T>) = Client.Attr.HandlerView \"DOMSubtreeModified\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"downloading\".\n        [<Inline; CompiledName \"downloading\">]\n        let Downloading_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"downloading\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"downloading\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"downloading\">]\n        let DownloadingView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"downloading\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"drag\".\n        [<Inline; CompiledName \"drag\">]\n        let Drag_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"drag\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"drag\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"drag\">]\n        let DragView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"drag\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dragend\".\n        [<Inline; CompiledName \"dragEnd\">]\n        let DragEnd_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"dragend\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dragend\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"dragEnd\">]\n        let DragEndView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"dragend\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dragenter\".\n        [<Inline; CompiledName \"dragEnter\">]\n        let DragEnter_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"dragenter\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dragenter\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"dragEnter\">]\n        let DragEnterView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"dragenter\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dragleave\".\n        [<Inline; CompiledName \"dragLeave\">]\n        let DragLeave_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"dragleave\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dragleave\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"dragLeave\">]\n        let DragLeaveView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"dragleave\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dragover\".\n        [<Inline; CompiledName \"dragOver\">]\n        let DragOver_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"dragover\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dragover\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"dragOver\">]\n        let DragOverView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"dragover\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dragstart\".\n        [<Inline; CompiledName \"dragStart\">]\n        let DragStart_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"dragstart\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"dragstart\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"dragStart\">]\n        let DragStartView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"dragstart\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"drop\".\n        [<Inline; CompiledName \"drop\">]\n        let Drop_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"drop\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"drop\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"drop\">]\n        let DropView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"drop\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"durationchange\".\n        [<Inline; CompiledName \"durationChange\">]\n        let DurationChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"durationchange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"durationchange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"durationChange\">]\n        let DurationChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"durationchange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"emptied\".\n        [<Inline; CompiledName \"emptied\">]\n        let Emptied_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"emptied\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"emptied\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"emptied\">]\n        let EmptiedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"emptied\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"ended\".\n        [<Inline; CompiledName \"ended\">]\n        let Ended_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"ended\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"ended\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"ended\">]\n        let EndedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"ended\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"endEvent\".\n        [<Inline; CompiledName \"endEvent\">]\n        let EndEvent_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"endEvent\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"endEvent\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"endEvent\">]\n        let EndEventView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"endEvent\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"error\".\n        [<Inline; CompiledName \"error\">]\n        let Error_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"error\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"error\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"error\">]\n        let ErrorView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"error\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"focus\".\n        [<Inline; CompiledName \"focus\">]\n        let Focus_ (f: System.Action<Dom.Element, Dom.FocusEvent>) = Client.Attr.Handler \"focus\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"focus\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"focus\">]\n        let FocusView (view: View<'T>) (f: System.Action<Dom.Element, Dom.FocusEvent, 'T>) = Client.Attr.HandlerView \"focus\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"fullscreenchange\".\n        [<Inline; CompiledName \"fullScreenChange\">]\n        let FullScreenChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"fullscreenchange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"fullscreenchange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"fullScreenChange\">]\n        let FullScreenChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"fullscreenchange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"fullscreenerror\".\n        [<Inline; CompiledName \"fullScreenError\">]\n        let FullScreenError_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"fullscreenerror\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"fullscreenerror\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"fullScreenError\">]\n        let FullScreenErrorView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"fullscreenerror\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"gamepadconnected\".\n        [<Inline; CompiledName \"gamepadConnected\">]\n        let GamepadConnected_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"gamepadconnected\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"gamepadconnected\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"gamepadConnected\">]\n        let GamepadConnectedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"gamepadconnected\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"gamepaddisconnected\".\n        [<Inline; CompiledName \"gamepadDisconnected\">]\n        let GamepadDisconnected_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"gamepaddisconnected\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"gamepaddisconnected\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"gamepadDisconnected\">]\n        let GamepadDisconnectedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"gamepaddisconnected\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"hashchange\".\n        [<Inline; CompiledName \"hashChange\">]\n        let HashChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"hashchange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"hashchange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"hashChange\">]\n        let HashChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"hashchange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"input\".\n        [<Inline; CompiledName \"input\">]\n        let Input_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"input\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"input\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"input\">]\n        let InputView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"input\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"invalid\".\n        [<Inline; CompiledName \"invalid\">]\n        let Invalid_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"invalid\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"invalid\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"invalid\">]\n        let InvalidView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"invalid\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"keydown\".\n        [<Inline; CompiledName \"keyDown\">]\n        let KeyDown_ (f: System.Action<Dom.Element, Dom.KeyboardEvent>) = Client.Attr.Handler \"keydown\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"keydown\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"keyDown\">]\n        let KeyDownView (view: View<'T>) (f: System.Action<Dom.Element, Dom.KeyboardEvent, 'T>) = Client.Attr.HandlerView \"keydown\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"keypress\".\n        [<Inline; CompiledName \"keyPress\">]\n        let KeyPress_ (f: System.Action<Dom.Element, Dom.KeyboardEvent>) = Client.Attr.Handler \"keypress\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"keypress\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"keyPress\">]\n        let KeyPressView (view: View<'T>) (f: System.Action<Dom.Element, Dom.KeyboardEvent, 'T>) = Client.Attr.HandlerView \"keypress\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"keyup\".\n        [<Inline; CompiledName \"keyUp\">]\n        let KeyUp_ (f: System.Action<Dom.Element, Dom.KeyboardEvent>) = Client.Attr.Handler \"keyup\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"keyup\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"keyUp\">]\n        let KeyUpView (view: View<'T>) (f: System.Action<Dom.Element, Dom.KeyboardEvent, 'T>) = Client.Attr.HandlerView \"keyup\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"languagechange\".\n        [<Inline; CompiledName \"languageChange\">]\n        let LanguageChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"languagechange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"languagechange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"languageChange\">]\n        let LanguageChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"languagechange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"levelchange\".\n        [<Inline; CompiledName \"levelChange\">]\n        let LevelChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"levelchange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"levelchange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"levelChange\">]\n        let LevelChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"levelchange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"load\".\n        [<Inline; CompiledName \"load\">]\n        let Load_ (f: System.Action<Dom.Element, Dom.UIEvent>) = Client.Attr.Handler \"load\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"load\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"load\">]\n        let LoadView (view: View<'T>) (f: System.Action<Dom.Element, Dom.UIEvent, 'T>) = Client.Attr.HandlerView \"load\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"loadeddata\".\n        [<Inline; CompiledName \"loadedData\">]\n        let LoadedData_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"loadeddata\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"loadeddata\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"loadedData\">]\n        let LoadedDataView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"loadeddata\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"loadedmetadata\".\n        [<Inline; CompiledName \"loadedMetadata\">]\n        let LoadedMetadata_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"loadedmetadata\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"loadedmetadata\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"loadedMetadata\">]\n        let LoadedMetadataView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"loadedmetadata\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"loadend\".\n        [<Inline; CompiledName \"loadEnd\">]\n        let LoadEnd_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"loadend\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"loadend\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"loadEnd\">]\n        let LoadEndView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"loadend\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"loadstart\".\n        [<Inline; CompiledName \"loadStart\">]\n        let LoadStart_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"loadstart\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"loadstart\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"loadStart\">]\n        let LoadStartView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"loadstart\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"message\".\n        [<Inline; CompiledName \"message\">]\n        let Message_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"message\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"message\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"message\">]\n        let MessageView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"message\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mousedown\".\n        [<Inline; CompiledName \"mouseDown\">]\n        let MouseDown_ (f: System.Action<Dom.Element, Dom.MouseEvent>) = Client.Attr.Handler \"mousedown\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mousedown\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"mouseDown\">]\n        let MouseDownView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MouseEvent, 'T>) = Client.Attr.HandlerView \"mousedown\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mouseenter\".\n        [<Inline; CompiledName \"mouseEnter\">]\n        let MouseEnter_ (f: System.Action<Dom.Element, Dom.MouseEvent>) = Client.Attr.Handler \"mouseenter\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mouseenter\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"mouseEnter\">]\n        let MouseEnterView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MouseEvent, 'T>) = Client.Attr.HandlerView \"mouseenter\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mouseleave\".\n        [<Inline; CompiledName \"mouseLeave\">]\n        let MouseLeave_ (f: System.Action<Dom.Element, Dom.MouseEvent>) = Client.Attr.Handler \"mouseleave\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mouseleave\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"mouseLeave\">]\n        let MouseLeaveView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MouseEvent, 'T>) = Client.Attr.HandlerView \"mouseleave\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mousemove\".\n        [<Inline; CompiledName \"mouseMove\">]\n        let MouseMove_ (f: System.Action<Dom.Element, Dom.MouseEvent>) = Client.Attr.Handler \"mousemove\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mousemove\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"mouseMove\">]\n        let MouseMoveView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MouseEvent, 'T>) = Client.Attr.HandlerView \"mousemove\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mouseout\".\n        [<Inline; CompiledName \"mouseOut\">]\n        let MouseOut_ (f: System.Action<Dom.Element, Dom.MouseEvent>) = Client.Attr.Handler \"mouseout\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mouseout\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"mouseOut\">]\n        let MouseOutView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MouseEvent, 'T>) = Client.Attr.HandlerView \"mouseout\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mouseover\".\n        [<Inline; CompiledName \"mouseOver\">]\n        let MouseOver_ (f: System.Action<Dom.Element, Dom.MouseEvent>) = Client.Attr.Handler \"mouseover\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mouseover\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"mouseOver\">]\n        let MouseOverView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MouseEvent, 'T>) = Client.Attr.HandlerView \"mouseover\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mouseup\".\n        [<Inline; CompiledName \"mouseUp\">]\n        let MouseUp_ (f: System.Action<Dom.Element, Dom.MouseEvent>) = Client.Attr.Handler \"mouseup\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"mouseup\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"mouseUp\">]\n        let MouseUpView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MouseEvent, 'T>) = Client.Attr.HandlerView \"mouseup\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"noupdate\".\n        [<Inline; CompiledName \"noUpdate\">]\n        let NoUpdate_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"noupdate\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"noupdate\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"noUpdate\">]\n        let NoUpdateView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"noupdate\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"obsolete\".\n        [<Inline; CompiledName \"obsolete\">]\n        let Obsolete_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"obsolete\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"obsolete\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"obsolete\">]\n        let ObsoleteView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"obsolete\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"offline\".\n        [<Inline; CompiledName \"offline\">]\n        let Offline_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"offline\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"offline\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"offline\">]\n        let OfflineView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"offline\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"online\".\n        [<Inline; CompiledName \"online\">]\n        let Online_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"online\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"online\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"online\">]\n        let OnlineView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"online\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"open\".\n        [<Inline; CompiledName \"open\">]\n        let Open_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"open\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"open\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"open\">]\n        let OpenView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"open\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"orientationchange\".\n        [<Inline; CompiledName \"orientationChange\">]\n        let OrientationChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"orientationchange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"orientationchange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"orientationChange\">]\n        let OrientationChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"orientationchange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"pagehide\".\n        [<Inline; CompiledName \"pageHide\">]\n        let PageHide_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"pagehide\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"pagehide\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"pageHide\">]\n        let PageHideView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"pagehide\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"pageshow\".\n        [<Inline; CompiledName \"pageShow\">]\n        let PageShow_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"pageshow\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"pageshow\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"pageShow\">]\n        let PageShowView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"pageshow\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"paste\".\n        [<Inline; CompiledName \"paste\">]\n        let Paste_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"paste\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"paste\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"paste\">]\n        let PasteView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"paste\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"pause\".\n        [<Inline; CompiledName \"pause\">]\n        let Pause_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"pause\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"pause\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"pause\">]\n        let PauseView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"pause\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"play\".\n        [<Inline; CompiledName \"play\">]\n        let Play_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"play\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"play\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"play\">]\n        let PlayView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"play\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"playing\".\n        [<Inline; CompiledName \"playing\">]\n        let Playing_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"playing\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"playing\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"playing\">]\n        let PlayingView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"playing\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"pointerlockchange\".\n        [<Inline; CompiledName \"pointerLockChange\">]\n        let PointerLockChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"pointerlockchange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"pointerlockchange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"pointerLockChange\">]\n        let PointerLockChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"pointerlockchange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"pointerlockerror\".\n        [<Inline; CompiledName \"pointerLockError\">]\n        let PointerLockError_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"pointerlockerror\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"pointerlockerror\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"pointerLockError\">]\n        let PointerLockErrorView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"pointerlockerror\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"popstate\".\n        [<Inline; CompiledName \"popState\">]\n        let PopState_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"popstate\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"popstate\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"popState\">]\n        let PopStateView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"popstate\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"progress\".\n        [<Inline; CompiledName \"progress\">]\n        let Progress_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"progress\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"progress\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"progress\">]\n        let ProgressView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"progress\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"ratechange\".\n        [<Inline; CompiledName \"rateChange\">]\n        let RateChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"ratechange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"ratechange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"rateChange\">]\n        let RateChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"ratechange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"readystatechange\".\n        [<Inline; CompiledName \"readyStateChange\">]\n        let ReadyStateChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"readystatechange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"readystatechange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"readyStateChange\">]\n        let ReadyStateChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"readystatechange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"repeatEvent\".\n        [<Inline; CompiledName \"repeatEvent\">]\n        let RepeatEvent_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"repeatEvent\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"repeatEvent\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"repeatEvent\">]\n        let RepeatEventView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"repeatEvent\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"reset\".\n        [<Inline; CompiledName \"reset\">]\n        let Reset_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"reset\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"reset\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"reset\">]\n        let ResetView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"reset\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"resize\".\n        [<Inline; CompiledName \"resize\">]\n        let Resize_ (f: System.Action<Dom.Element, Dom.UIEvent>) = Client.Attr.Handler \"resize\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"resize\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"resize\">]\n        let ResizeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.UIEvent, 'T>) = Client.Attr.HandlerView \"resize\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"scroll\".\n        [<Inline; CompiledName \"scroll\">]\n        let Scroll_ (f: System.Action<Dom.Element, Dom.UIEvent>) = Client.Attr.Handler \"scroll\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"scroll\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"scroll\">]\n        let ScrollView (view: View<'T>) (f: System.Action<Dom.Element, Dom.UIEvent, 'T>) = Client.Attr.HandlerView \"scroll\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"seeked\".\n        [<Inline; CompiledName \"seeked\">]\n        let Seeked_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"seeked\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"seeked\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"seeked\">]\n        let SeekedView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"seeked\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"seeking\".\n        [<Inline; CompiledName \"seeking\">]\n        let Seeking_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"seeking\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"seeking\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"seeking\">]\n        let SeekingView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"seeking\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"select\".\n        [<Inline; CompiledName \"select\">]\n        let Select_ (f: System.Action<Dom.Element, Dom.UIEvent>) = Client.Attr.Handler \"select\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"select\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"select\">]\n        let SelectView (view: View<'T>) (f: System.Action<Dom.Element, Dom.UIEvent, 'T>) = Client.Attr.HandlerView \"select\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"show\".\n        [<Inline; CompiledName \"show\">]\n        let Show_ (f: System.Action<Dom.Element, Dom.MouseEvent>) = Client.Attr.Handler \"show\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"show\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"show\">]\n        let ShowView (view: View<'T>) (f: System.Action<Dom.Element, Dom.MouseEvent, 'T>) = Client.Attr.HandlerView \"show\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"stalled\".\n        [<Inline; CompiledName \"stalled\">]\n        let Stalled_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"stalled\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"stalled\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"stalled\">]\n        let StalledView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"stalled\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"storage\".\n        [<Inline; CompiledName \"storage\">]\n        let Storage_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"storage\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"storage\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"storage\">]\n        let StorageView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"storage\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"submit\".\n        [<Inline; CompiledName \"submit\">]\n        let Submit_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"submit\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"submit\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"submit\">]\n        let SubmitView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"submit\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"success\".\n        [<Inline; CompiledName \"success\">]\n        let Success_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"success\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"success\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"success\">]\n        let SuccessView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"success\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"suspend\".\n        [<Inline; CompiledName \"suspend\">]\n        let Suspend_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"suspend\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"suspend\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"suspend\">]\n        let SuspendView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"suspend\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGAbort\".\n        [<Inline; CompiledName \"SVGAbort\">]\n        let SVGAbort_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"SVGAbort\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGAbort\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"SVGAbort\">]\n        let SVGAbortView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"SVGAbort\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGError\".\n        [<Inline; CompiledName \"SVGError\">]\n        let SVGError_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"SVGError\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGError\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"SVGError\">]\n        let SVGErrorView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"SVGError\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGLoad\".\n        [<Inline; CompiledName \"SVGLoad\">]\n        let SVGLoad_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"SVGLoad\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGLoad\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"SVGLoad\">]\n        let SVGLoadView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"SVGLoad\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGResize\".\n        [<Inline; CompiledName \"SVGResize\">]\n        let SVGResize_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"SVGResize\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGResize\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"SVGResize\">]\n        let SVGResizeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"SVGResize\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGScroll\".\n        [<Inline; CompiledName \"SVGScroll\">]\n        let SVGScroll_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"SVGScroll\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGScroll\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"SVGScroll\">]\n        let SVGScrollView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"SVGScroll\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGUnload\".\n        [<Inline; CompiledName \"SVGUnload\">]\n        let SVGUnload_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"SVGUnload\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGUnload\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"SVGUnload\">]\n        let SVGUnloadView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"SVGUnload\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGZoom\".\n        [<Inline; CompiledName \"SVGZoom\">]\n        let SVGZoom_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"SVGZoom\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"SVGZoom\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"SVGZoom\">]\n        let SVGZoomView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"SVGZoom\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"timeout\".\n        [<Inline; CompiledName \"timeOut\">]\n        let TimeOut_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"timeout\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"timeout\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"timeOut\">]\n        let TimeOutView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"timeout\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"timeupdate\".\n        [<Inline; CompiledName \"timeUpdate\">]\n        let TimeUpdate_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"timeupdate\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"timeupdate\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"timeUpdate\">]\n        let TimeUpdateView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"timeupdate\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"touchcancel\".\n        [<Inline; CompiledName \"touchCancel\">]\n        let TouchCancel_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"touchcancel\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"touchcancel\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"touchCancel\">]\n        let TouchCancelView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"touchcancel\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"touchend\".\n        [<Inline; CompiledName \"touchEnd\">]\n        let TouchEnd_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"touchend\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"touchend\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"touchEnd\">]\n        let TouchEndView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"touchend\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"touchenter\".\n        [<Inline; CompiledName \"touchEnter\">]\n        let TouchEnter_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"touchenter\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"touchenter\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"touchEnter\">]\n        let TouchEnterView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"touchenter\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"touchleave\".\n        [<Inline; CompiledName \"touchLeave\">]\n        let TouchLeave_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"touchleave\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"touchleave\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"touchLeave\">]\n        let TouchLeaveView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"touchleave\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"touchmove\".\n        [<Inline; CompiledName \"touchMove\">]\n        let TouchMove_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"touchmove\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"touchmove\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"touchMove\">]\n        let TouchMoveView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"touchmove\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"touchstart\".\n        [<Inline; CompiledName \"touchStart\">]\n        let TouchStart_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"touchstart\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"touchstart\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"touchStart\">]\n        let TouchStartView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"touchstart\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"transitionend\".\n        [<Inline; CompiledName \"transitionEnd\">]\n        let TransitionEnd_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"transitionend\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"transitionend\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"transitionEnd\">]\n        let TransitionEndView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"transitionend\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"unload\".\n        [<Inline; CompiledName \"unload\">]\n        let Unload_ (f: System.Action<Dom.Element, Dom.UIEvent>) = Client.Attr.Handler \"unload\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"unload\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"unload\">]\n        let UnloadView (view: View<'T>) (f: System.Action<Dom.Element, Dom.UIEvent, 'T>) = Client.Attr.HandlerView \"unload\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"updateready\".\n        [<Inline; CompiledName \"updateReady\">]\n        let UpdateReady_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"updateready\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"updateready\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"updateReady\">]\n        let UpdateReadyView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"updateready\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"upgradeneeded\".\n        [<Inline; CompiledName \"upgradeNeeded\">]\n        let UpgradeNeeded_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"upgradeneeded\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"upgradeneeded\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"upgradeNeeded\">]\n        let UpgradeNeededView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"upgradeneeded\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"userproximity\".\n        [<Inline; CompiledName \"userProximity\">]\n        let UserProximity_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"userproximity\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"userproximity\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"userProximity\">]\n        let UserProximityView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"userproximity\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"versionchange\".\n        [<Inline; CompiledName \"versionChange\">]\n        let VersionChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"versionchange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"versionchange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"versionChange\">]\n        let VersionChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"versionchange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"visibilitychange\".\n        [<Inline; CompiledName \"visibilityChange\">]\n        let VisibilityChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"visibilitychange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"visibilitychange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"visibilityChange\">]\n        let VisibilityChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"visibilitychange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"volumechange\".\n        [<Inline; CompiledName \"volumeChange\">]\n        let VolumeChange_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"volumechange\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"volumechange\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"volumeChange\">]\n        let VolumeChangeView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"volumechange\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"waiting\".\n        [<Inline; CompiledName \"waiting\">]\n        let Waiting_ (f: System.Action<Dom.Element, Dom.Event>) = Client.Attr.Handler \"waiting\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"waiting\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"waiting\">]\n        let WaitingView (view: View<'T>) (f: System.Action<Dom.Element, Dom.Event, 'T>) = Client.Attr.HandlerView \"waiting\" view (FSharpConvert.Fun f)\n        /// Create a handler for the event \"wheel\".\n        [<Inline; CompiledName \"wheel\">]\n        let Wheel_ (f: System.Action<Dom.Element, Dom.WheelEvent>) = Client.Attr.Handler \"wheel\" (FSharpConvert.Fun f)\n        /// Create a handler for the event \"wheel\" which also receives the value of a view at the time of the event.\n        [<Inline; CompiledName \"wheel\">]\n        let WheelView (view: View<'T>) (f: System.Action<Dom.Element, Dom.WheelEvent, 'T>) = Client.Attr.HandlerView \"wheel\" view (FSharpConvert.Fun f)\n        // }}\n", "// $begin{copyright}\n//\n// This file is part of WebSharper\n//\n// Copyright (c) 2008-2018 IntelliFactory\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you\n// may not use this file except in compliance with the License.  You may\n// obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n// implied.  See the License for the specific language governing\n// permissions and limitations under the License.\n//\n// $end{copyright}\n\nnamespace WebSharper.UI.Client\n\nopen System\nopen System.Collections.Generic\nopen WebSharper\nopen WebSharper.JavaScript\nopen WebSharper.UI\nopen WebSharper.UI.Client\nopen WebSharper.Core\nopen WebSharper.Core.AST\ntype private BF = System.Reflection.BindingFlags\n\n[<AutoOpen>]\nmodule private Internals =\n\n    let inline nameOf x =\n        let o =\n            (^T : (member GetCustomAttributesData : unit -> IList<Reflection.CustomAttributeData>)(x))\n            |> Seq.tryPick (fun cad ->\n                if cad.Constructor.DeclaringType = typeof<NameAttribute> then\n                    Some (cad.ConstructorArguments.[0].Value :?> string)\n                else None\n            )\n        defaultArg o (^T : (member Name : string)(x))\n\n[<JavaScript>]\ntype RouteMapBuilder() =\n\n    let mutable links : list<obj -> option<list<string> * Map<string, string>>> = []\n    let mutable routes : list<list<string> * Map<string, string> -> option<obj>> = []\n    let mutable renders : list<Func<Action<obj>, obj, option<Doc>>> = []\n\n    [<Macro(typeof<RouteMapBuilderMacro>)>]\n    member private this.Route<'T>() = X<list<string> * Map<string, string> -> option<obj>>\n\n    [<Macro(typeof<RouteMapBuilderMacro>)>]\n    member private this.Link<'T>() = X<obj -> option<list<string> * Map<string, string>>>\n\n    [<Macro(typeof<RouteMapBuilderMacro>)>]\n    member private this.Render<'T>(render: Func<Action<obj>, 'T, Doc>) = X<Func<Action<obj>, obj, option<Doc>>>\n\n    member private this.AddRoute(r) = routes <- r :: routes\n\n    member private this.AddLink(l) = links <- l :: links\n\n    member private this.AddRender(r) = renders <- r :: renders\n\n    [<Inline>]\n    member this.With<'T>(render: Func<Action<obj>, 'T, Doc>) =\n        this.AddRoute(this.Route<'T>())\n        this.AddLink(this.Link<'T>())\n        this.AddRender(this.Render<'T>(render))\n        this\n\n    member this.ToRouteMap() =\n        let links = List.rev links\n        let routes = List.rev routes\n        RouteMap.CreateWithQuery\n            (fun a -> List.pick ((|>) a) links)\n            (fun r -> List.pick ((|>) r) routes)\n\n    member this.Install() =\n        let routeMap = this.ToRouteMap()\n        let var = RouteMap.Install routeMap\n        let renders = renders |> List.rev |> List.map (fun f -> fun r -> f.Invoke(Action<obj>(Var.Set var), r))\n        var.View.Doc(fun r -> List.pick ((|>) r) renders)\n\nand private ParseFunc = list<string> * Map<string, string> -> option<obj * list<string>>\nand private LinkFunc = obj -> list<string> * Map<string, string>\n\nand private RouteObjectArgs = array<string * QueryItem * ParseFunc * LinkFunc>\n\nand private RouteShape =\n    | Base of ParseFunc // assuming string as LinkFunc\n    | Object of ctor: (unit -> obj) * name: option<string> * args: RouteObjectArgs \n    | Sequence of fromArray: (array<obj> -> obj) * parseItem: ParseFunc * linkItem: LinkFunc\n    | Tuple of items: array<ParseFunc * LinkFunc>\n\nand private MetaRootShape =\n    | MetaBase of parse: Method\n    | MetaObject of ctor: Expression * name: option<string> * args: list<string * QueryItem * Type>\n    | MetaSequence of fromArray: Expression * item: Type\n    | MetaTuple of items: list<Type>\n\nand private QueryItem =\n    | NotQuery = 0\n    | Mandatory = 1\n    | Option = 2                                                                                       \n    | Nullable = 3\n\nand private RouteMapBuilderMacro() =\n    inherit Macro()\n\n    let mutable comp = Unchecked.defaultof<Metadata.ICompilation>\n    let fsCoreType name = Hashed { Assembly = \"FSharp.Core\"; FullName = \"Microsoft.FSharp.\" + name }\n    let sysType name = Hashed { Assembly = \"netstandard\"; FullName = name }\n    let optionOf' t = Generic (fsCoreType \"Core.FSharpOption`1\") [t]\n    let optionOf t = ConcreteType (optionOf' t)\n    let some t v = NewUnionCase (optionOf' t, \"Some\", [v])\n    let none t = NewUnionCase (optionOf' t, \"None\", [])\n    let listT = Reflection.ReadTypeDefinition typedefof<list<_>>\n    let listOf' t = Generic (fsCoreType \"Collections.FSharpList`1\") [t]\n    let listOf t = ConcreteType (listOf' t)\n    let mapOf t u = GenericType (Reflection.ReadTypeDefinition typedefof<Map<_, _>>) [t; u]\n    let arrayModule = NonGeneric (fsCoreType \"Collections.ArrayModule\")\n    let emptyList t = NewUnionCase (listOf' t, \"Empty\", [])\n    let cons t hd tl = NewUnionCase (listOf' t, \"Cons\", [hd; tl])\n    let stringT = NonGenericType (sysType \"System.String\")\n    let stringMapT = mapOf stringT stringT\n    let objT = NonGenericType (sysType \"System.Object\")\n    let parsersT = Reflection.ReadTypeDefinition typeof<RouteItemParsers>\n    let routeItemParsersT = NonGeneric parsersT\n    let parseRouteM =\n        typeof<RouteItemParsers>.GetMethod(\"ParseRoute\", BF.Static ||| BF.NonPublic)\n        |> Reflection.ReadMethod |> NonGeneric\n    let parseShapeM =\n        typeof<RouteItemParsers>.GetMethod(\"ParseShape\", BF.Static ||| BF.NonPublic)\n        |> Reflection.ReadMethod |> NonGeneric\n    let makeLinkM =\n        typeof<RouteItemParsers>.GetMethod(\"MakeLink\", BF.Static ||| BF.NonPublic)\n        |> Reflection.ReadMethod |> NonGeneric\n\n    let getDefaultCtor (t: Type) =\n        match t with\n        | ConcreteType ct ->\n            let defaultCtor = Hashed { CtorParameters = [] }\n            let info = comp.GetClassInfo ct.Entity\n            match comp.GetClassInfo ct.Entity with\n            | None -> failwithf \"Endpoint type must have JavaScript translation: %s\" t.AssemblyQualifiedName\n            | Some cls ->\n                if cls.Constructors.ContainsKey defaultCtor \n                then Lambda([], Ctor (ct, defaultCtor, [])), ct.Entity, info.Value\n                else failwithf \"Endpoint type must have a default constructor: %s\" t.AssemblyQualifiedName\n        // TODO: handle TupleType etc\n        | _ -> failwithf \"Generic endpoint type not supported for routing: %s\" t.AssemblyQualifiedName\n\n//    let internals = Hashed { Assembly = \"WebSharper.UI.Next.CSharp\"; FullName = \"RoutingInternals\" }\n//    let getInternals() =\n//        match comp.TryLookupClassInfo internals with\n//        | Some cl -> cl\n//        | None ->\n//            comp.AddClass(internals, {\n//                StrongName = None\n//                BaseClass = None\n//                Requires = []\n//                Members = []\n//                IsModule = true\n//                IsProxy = false\n//                Macros = []\n//            })\n//            comp.TryLookupClassInfo internals |> Option.get\n//    let getOrAddMethod name argTys returnTy impl =\n//        let internals' = getInternals()\n//        let meth = Hashed {\n//            MethodName = name\n//            Parameters = argTys\n//            ReturnType = returnTy\n//            Generics = 0\n//        }\n//        match comp.LookupMethodInfo(internals, meth) with\n//        | Metadata.Compiled _ -> ()\n//        | _ -> comp.AddCompiledMethod(internals, meth, Metadata.Instance name, impl)\n//        meth\n\n    let isBaseType (ty: Type) =\n        match ty with\n        | ConcreteType { Entity = td } ->\n            match td.Value.FullName with\n            | \"System.SByte\"    | \"System.Byte\"\n            | \"System.Int16\"    | \"System.UInt16\"\n            | \"System.Int32\"    | \"System.UInt32\"\n            | \"System.Int64\"    | \"System.UInt64\"\n            | \"System.Single\"   | \"System.Double\"\n            | \"System.String\" -> true\n            | _ -> false\n        | _ -> false\n\n    let getRouteShape (t: Type) =\n        match t with\n        | ConcreteType td ->\n            if td.Entity = listT then\n                let itemT = td.Generics.[0]\n                let fromArray =\n                    Hashed {\n                        MethodName = \"ToList\"\n                        Parameters = [ArrayType (TypeParameter 0, 1)]\n                        ReturnType = listOf (TypeParameter 0)\n                        Generics = 1\n                    }\n                let x = Id.New()\n                MetaSequence (\n                    Lambda([x], Call (None, arrayModule, Generic fromArray [itemT], [Var x])),\n                    itemT\n                )\n            else\n                let meth args res =\n                    Hashed {\n                        MethodName = t.TypeDefinition.Value.FullName\n                        Parameters = args\n                        ReturnType = res\n                        Generics = 0\n                    }\n                let parseMeth = meth [TupleType ([listOf stringT; stringMapT], false)] (optionOf (TupleType ([t; listOf stringT], false)))\n                if comp.GetClassInfo parsersT |> Option.exists (fun cls -> cls.Methods.ContainsKey parseMeth)\n                then MetaBase parseMeth\n                else\n                    let ctor, td, cls = getDefaultCtor t\n                    let endpoint =\n                        match comp.GetTypeAttributes td with\n                        | Some attrs ->\n                            match attrs |> List.tryFind (fun (at, _) -> at.Value.FullName = \"WebSharper.EndPointAttribute\") with\n                            | Some (_, [| Metadata.ParameterObject.String ep |]) -> ep\n                            | _ -> \"/\"\n                        | _ -> \"/\"\n                    let fields =\n                        cls.Fields\n//                        t'.GetFields(BF.Instance ||| BF.Public ||| BF.NonPublic)\n                        |> Seq.choose (fun (KeyValue(compName, f)) ->\n                            match f with\n                            | Metadata.InstanceField name, _, ftyp \n                            | Metadata.OptionalField name, _, ftyp -> \n                                comp.GetFieldAttributes(td, compName) |> Option.map (fun fattrs ->\n                                    let isQuery =\n                                        fattrs\n                                        |> Seq.exists (fun (at, args) ->\n                                            at.Value.FullName = \"WebSharper.QueryAttribute\" &&\n                                                Array.isEmpty args\n                                        )\n                                    if isQuery then\n                                        let queryItem, ty =\n                                            match ftyp with\n                                            | ConcreteType { Entity = ftd; Generics = [ g ] } ->\n                                                match ftd.Value.FullName with\n                                                | \"Microsoft.FSharp.Core.FSharpOption`1\" ->\n                                                    QueryItem.Option, g\n                                                | \"System.Nullable`1\" ->\n                                                    QueryItem.Nullable, g\n                                                | _ -> QueryItem.Mandatory, ftyp\n                                            | _ -> QueryItem.Mandatory, ftyp\n                                        if not (isBaseType ty) then\n                                            failwithf \"Invalid query parameter type for %s: %s. Must be a number, string, or an option thereof.\"\n                                                name ty.AssemblyQualifiedName\n                                        name, queryItem, ty\n                                    else name, QueryItem.NotQuery, ftyp\n                                )\n                            | Metadata.IndexedField _, _, ftyp ->\n                                failwithf \"Field translated to an index is not supported for routing %s: %s.\"\n                                    compName ftyp.AssemblyQualifiedName\n                            | Metadata.StaticField _, _, _ -> None\n                        ) \n                        |> List.ofSeq\n                    let isHole (n: string) = n.StartsWith \"{\" && n.EndsWith \"}\"\n                    match endpoint.[endpoint.IndexOf('/') + 1 ..].Split([|'/'|], StringSplitOptions.RemoveEmptyEntries) with\n                    | [||] -> MetaObject (ctor, None, fields)\n                    | [| name |] when not (isHole name) -> MetaObject (ctor, Some name, fields)\n                    | a ->\n                        let name, a =\n                            if isHole a.[0] then\n                                None, a\n                            else\n                                Some a.[0], a.[1..]\n                        let args =\n                            a.[1..]\n                            |> Array.map (fun n ->\n                                if isHole n then\n                                    let name = n.[1..n.Length-2]\n                                    match fields |> List.tryFind (fun (n, _, _) -> name = n) with\n                                    | Some f -> f\n                                    | None -> failwithf \"Path argument doesn't correspond to a field: %s\" n\n                                else\n                                    failwith \"Path arguments must be of the shape: {fieldName}\")\n                            |> List.ofArray\n                        MetaObject (ctor, name, args)\n        | ArrayType (t, 1) ->\n            MetaSequence((let x = Id.New() in Lambda([x], Var x)), t)\n        | TupleType (ts, _) ->\n            MetaTuple ts\n        | t -> failwithf \"Type not supported by RouteMap: %s\" t.AssemblyQualifiedName\n\n    let routeShapeT = NonGeneric (Reflection.ReadTypeDefinition typeof<RouteShape>)\n    let rec convertRouteShape = function\n        | MetaBase parse ->\n            NewUnionCase(routeShapeT, \"Base\",\n                [\n                    (let x = Id.New()\n                     let y = Id.New()\n                     Lambda ([x; y],\n                        Call (None, NonGeneric parsersT, NonGeneric parse, [Var x; Var y])))\n                ]\n            )\n        | MetaObject (init, name, args) ->\n            NewUnionCase (routeShapeT, \"Object\",\n                [\n                    init\n                    (match name with\n                    | Some name -> some stringT (Value (String name))\n                    | None -> none stringT)\n                    NewArray (args |> List.map (fun (argName, queryItem, argType) ->\n                        let shape = getRouteShape argType |> convertRouteShape\n                        let shapeId = Id.New()\n                        Let(shapeId, shape,\n                            NewArray [\n                                Value (String argName)\n                                Value (Int (int queryItem))\n                                Call (None, routeItemParsersT, parseShapeM, [Var shapeId])\n                                Call (None, routeItemParsersT, makeLinkM, [Var shapeId])\n                            ]\n                        )\n                    ))\n                ])\n        | MetaSequence (fromArray, item) ->\n            let shape = getRouteShape item |> convertRouteShape\n            let shapeId = Id.New()\n            Let(shapeId, shape,\n                NewUnionCase (routeShapeT, \"Sequence\",\n                    [\n                        fromArray\n                        Call (None, routeItemParsersT, parseShapeM, [Var shapeId])\n                        Call (None, routeItemParsersT, makeLinkM, [Var shapeId])\n                    ])\n            )\n        | MetaTuple items ->\n            let shapes =\n                items |> List.map (fun item ->\n                    let shape = getRouteShape item |> convertRouteShape\n                    let shapeId = Id.New()\n                    Let(shapeId, shape,\n                        NewArray [\n                            Call (None, routeItemParsersT, parseShapeM, [Var shapeId])\n                            Call (None, routeItemParsersT, makeLinkM, [Var shapeId])\n                        ]))\n            NewUnionCase (routeShapeT, \"Tuple\", [NewArray shapes])\n\n    override __.TranslateCall(c) =\n        comp <- c.Compilation\n        let targ = c.Method.Generics.[0] \n        if targ.IsParameter then MacroNeedsResolvedTypeArg targ else\n        try\n            match c.Method.Entity.Value.MethodName with\n            | \"Link\" ->\n                let mk = Id.New()\n                let action = Id.New()\n                let routeShape = getRouteShape targ |> convertRouteShape\n                Let (mk, Call (None, routeItemParsersT, makeLinkM, [routeShape]),\n                    Lambda ([action],\n                        Conditional (TypeCheck (Var action, targ),\n                            some (listOf stringT) (Application (Var mk, [Var action], Pure, Some 1)),\n                            none (listOf stringT)\n                        )\n                    )\n                )\n            | \"Route\" ->\n                let routeShape = getRouteShape targ |> convertRouteShape\n                Call (None, routeItemParsersT, parseRouteM, [routeShape])\n            | \"Render\" ->\n                let go = Id.New()\n                let action = Id.New()\n                let render = c.Arguments.[0]\n                Lambda([go; action],\n                    Conditional (TypeCheck (Var action, targ),\n                        some targ (Application (render, [Var go; Var action], Pure, Some 2)),\n                        none targ\n                    )\n                )\n            | _ -> failwith \"Invalid use of RouteMapBuilder macro\"\n            |> MacroOk\n        with e -> MacroError e.Message\n\nand [<JavaScript>] private RouteItemParsers =\n\n    static member private ParseShape(shape: RouteShape) : ParseFunc =\n        fun (path: list<string>, query: Map<string, string>) ->\n            let parseArgs (init: unit -> obj) (rest: list<string>) (args: RouteObjectArgs) =\n                let v = init()\n                (Some rest, args)\n                ||> Array.fold (fun rest (name, queryItem, parse, _) ->\n                    match rest with\n                    | None -> None\n                    | Some rest ->\n                        match queryItem with\n                        | QueryItem.NotQuery ->\n                            match parse (rest, query) with\n                            | None -> None\n                            | Some (parsed, rest) ->\n                                v?(name) <- parsed\n                                Some rest\n                        | QueryItem.Option ->\n                            match Map.tryFind name query with\n                            | None ->\n                                v?(name) <- None\n                                Some rest\n                            | Some x ->\n                                match parse ([x], Map.empty) with\n                                | None -> None\n                                | Some (x, _) ->\n                                    v?(name) <- Some x\n                                    Some rest\n                        | QueryItem.Nullable ->\n                            match Map.tryFind name query with\n                            | None ->\n                                v?(name) <- Nullable()\n                                Some rest\n                            | Some x ->\n                                match parse ([x], Map.empty) with\n                                | None -> None\n                                | Some (x, _) ->\n                                    v?(name) <- Nullable(As<int> x)\n                                    Some rest\n                        | QueryItem.Mandatory ->\n                            match Map.tryFind name query with\n                            | Some x -> v?(name) <- x; Some rest\n                            | None -> None\n                        | _ -> failwith \"invalid QueryItem enum value\"\n                )\n                |> Option.map (fun rest -> (v, rest))\n            match shape with\n            | Base f -> f (path, query)\n            | Object (init, Some name, args) ->\n                match path with\n                | root :: rest when root = name -> parseArgs init rest args\n                | _ -> None\n            | Object (init, None, args) -> parseArgs init path args\n            | Sequence (fromArray, parseItem, _) ->\n                RouteItemParsers.``System.Int32``(path, query)\n                |> Option.bind (fun (length, rest) ->\n                    let arr = Array.zeroCreate<obj> length\n                    let rec set i rest =\n                        if i = length then\n                            Some (fromArray arr, rest)\n                        else\n                            match parseItem (rest, query) with\n                            | None -> None\n                            | Some (item, rest) ->\n                                arr.[i] <- item\n                                set (i + 1) rest\n                    set 0 rest\n                )\n            | Tuple items ->\n                let t = JavaScript.Array()\n                (Some path, items)\n                ||> Array.fold (fun rest (parse, _) ->\n                    rest |> Option.bind (fun rest ->\n                        parse (rest, query) |> Option.map (fun (parsed, rest) ->\n                            t.Push(parsed) |> ignore\n                            rest)))\n                |> Option.map (fun rest -> (box t, rest))\n\n    static member private ParseRoute(shape) =\n        RouteItemParsers.ParseShape(shape) >> Option.bind (function\n            | x, [] -> Some x\n            | _ -> None\n        )\n\n    static member private MakeLink(shape: RouteShape) : LinkFunc =\n        fun (value: obj) ->\n            match shape with\n            | Base _ -> [string value], Map.empty\n            | Object (_, name, args) ->\n                let map = ref Map.empty\n                let l =\n                    Option.toList name @\n                    (args\n                    |> Seq.collect (fun (name, queryItem, _, link) ->\n                        match queryItem with\n                        | QueryItem.NotQuery ->\n                            let l, m = link value?(name)\n                            map := Map.foldBack Map.add m !map\n                            l\n                        | QueryItem.Option ->\n                            match value?(name) with\n                            | None -> ()\n                            | Some x ->\n                                let x = link x |> fst |> List.head\n                                map := Map.add name x !map\n                            []\n                        | QueryItem.Nullable ->\n                            let v = As<Nullable<_>> (value?(name))\n                            if v.HasValue then\n                                let x = link v.Value |> fst |> List.head\n                                map := Map.add name x !map\n                            []\n                        | QueryItem.Mandatory ->\n                            let x = link value?(name) |> fst |> List.head\n                            map := Map.add name x !map\n                            []\n                        | _ -> failwith \"invalid QueryItem enum value\"\n                    )\n                    |> List.ofSeq)\n                l, !map\n            | Sequence (_, _, linkItem) ->\n                let s = value :?> seq<obj>\n                string (Seq.length s) ::\n                (value :?> seq<obj>\n                |> Seq.collect (linkItem >> fst)\n                |> List.ofSeq), Map.empty\n            | Tuple items ->\n                (items, (value :?> obj[]))\n                ||> Seq.map2 (fun (_, link) x -> link x |> fst)\n                |> Seq.concat\n                |> List.ofSeq, Map.empty\n\n    static member ``System.String``((x: list<string>, q: Map<string, string>)) =\n        match x with\n        | [] -> None\n        | x :: rest -> Some (x, rest)\n\n    static member ``System.Int32``((x: list<string>, q: Map<string, string>)) =\n        match x with\n        | [] -> None\n        | x :: rest ->\n            match RegExp(\"^[0-9]+$\").Exec(x) with\n            | null -> None\n            | a -> Some (JS.ParseInt a.[0], rest)\n\n    [<Inline>]\n    static member ``System.SByte``(xq: list<string> * Map<string, string>) = As<option<System.SByte * list<string>>>(RouteItemParsers.``System.Int32``(xq))\n    [<Inline>]\n    static member ``System.Byte``(xq: list<string> * Map<string, string>) = As<option<System.Byte * list<string>>>(RouteItemParsers.``System.Int32``(xq))\n    [<Inline>]\n    static member ``System.Int16``(xq: list<string> * Map<string, string>) = As<option<System.Int16 * list<string>>>(RouteItemParsers.``System.Int32``(xq))\n    [<Inline>]\n    static member ``System.UInt16``(xq: list<string> * Map<string, string>) = As<option<System.UInt16 * list<string>>>(RouteItemParsers.``System.Int32``(xq))\n    [<Inline>]\n    static member ``System.UInt32``(xq: list<string> * Map<string, string>) = As<option<System.UInt32 * list<string>>>(RouteItemParsers.``System.Int32``(xq))\n    [<Inline>]\n    static member ``System.Int64``(xq: list<string> * Map<string, string>) = As<option<System.Int64 * list<string>>>(RouteItemParsers.``System.Int32``(xq))\n    [<Inline>]\n    static member ``System.UInt64``(xq: list<string> * Map<string, string>) = As<option<System.UInt64 * list<string>>>(RouteItemParsers.``System.Int32``(xq))\n\n    static member ``System.Double``((x: list<string>, q: Map<string, string>)) =\n        match x with\n        | [] -> None\n        | x :: rest ->\n            match RegExp(@\"^[0-9](?:\\.[0-9]*)?$\").Exec(x) with\n            | null -> None\n            | a -> Some (JS.ParseFloat a.[0], rest)\n\n    [<Inline>]\n    static member ``System.Single``(xq: list<string> * Map<string, string>) = As<option<System.Single * list<string>>>(RouteItemParsers.``System.Double``(xq))\n"],
"names": [],
"mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;S,AA6FQ,iBAAA,CAAkB,C,AAAlB,EAAkB,C,AAAlB,EAAkB,C,AAAM,C;;;;S,AA+DxB,6BAAwD,C;;;;S,AALxD;;;;;;4BAAoD,C;;;;S,AALpD,kDAAoD,C;;;;S,AALpD,oBAAgC,CAAmB,C,AAAE,CAAmB,G,AAAC,C;;;;S,AALzE,iBAAgC,CAAmB,C,AAAG;;;;;;GAAmB,C,AAAE,CAAC,C,AAAA,C;;;;S,ACxG5E,WAAA,CAAU,C,AAAV,UAAU,C,AAAV;;UAA6B,CAAC,C;G,AAApB,C,AAAuC,C;;;;;;;;W,ACoDgB,CAAC,C,AAAmB;;YAAA,UAAC,IAAW,C,AAAX,CAAW,C,AAAC,C;K,AAAA,C,AAAE,CAAC,C,AAAC,C;;Q,AAD5F,iBADK,IAAI,a,AACgB,C,AAAA,C;W,AACrB,SAAuB;;;;;;IAAkE,C,AAA9E,QAAQ,C,AAAnB,IAAO,Q,AAAA,C,AAAkF,C,AAAA,C;U,AACvG,aAAa;;WAAS,SAAY;;YAAA,CAAK,G,AAAA,C;K,AAAA,C,AAAE,OAAO,C,AAAA,C;I,AAAA,C,AAAhD,IAAG,W,AAAK,C,AAAyC,C;;;;;S,AAVrC,SAAS,IAAK,M,AAAA,C,AAAA,C;U,AACb,SAAS,IAAM,O,AAAA,C,AAAA,C;U,AAC5B,yBAAA;;WACc,SAAY;;YAAA,CAAK,G,AAAA,C;K,AAAA,C,AAAE,KAAK,C,AAAA,C;I,AAAC,C,AADvC;;WAEc,SAAY;;YAAA,CAAK,G,AAAA,C;K,AAAA,C,AAAE,MAAM,C,AAAA,C;I,AADA,C,AACC,C;;;;G,AAdT,IAAuB,S,AAAZ;;OAAA,CAAC,C;O,AAAI,IAAO,Q,AAAA;K,AAAA,C;;;;G,AAFzB,IAAmB,O,AAAV;;OAAA,CAAC,C;O,AAAI,IAAK,M,AAAA;K,AAAA,C;;;;G,AAFlB,IAAqB,Q,AAAX;;OAAA,CAAC,C;O,AAAI,IAAM,O,AAAA;K,AAAA,C;;;;;;E,AAbvD,IAAgF,O,AAAF,YAAE,C;E,AAChF,IAAiF,Q,AAAF,YAAE,C;E,AACjF,IAAoE,S,AAAF,YAAE,C;;;;;I,AAmfnC,CAAuC,G,AAAA,C;S,AAC9D,CAAC,K,AAAA,E,AAAD,EAGI,CAAA,kBAAO,uBAAuB,C,AAAC,O,AAA/B,CAAuC,G,AAAD,C,AAAC,C,AAAvC,iBAAA,CAAuC,C,AAAvC,IAAuC,C,AAAA,C,AACnC,IAAI,C,AACP;;MAAM,CAAA,kBAAc,WAAA,CAAC,C,AAAE,CAAC,C,AAAC,C,AAAA,C,AAF1B,CAAuC,G,AAEP,C,AAAA;G,AAAC,E,AALrC,IAAC,C;;;;;I,AAxBqB,CAAuC,G,AAAA,C;S,AAC7D,CAAC,K,AAAA,E,AAAD,EAGI,CAAA,kBAAO,UAAU,C,AAAC,O,AAAlB,CAA0B,G,AAAD,C,AAAC,C,AAA1B,iBAAA,CAA0B,C,AAA1B,IAA0B,C,AAAA,C,AACtB,IAAI,C,AACP;;MAAM,CAAA,gBAAY,WAAA,CAAC,C,AAAE,CAAC,C,AAAC,e,AAAA,C,AAFxB,CAA0B,G,AAEI,C,AAAA;G,AAAC,E,AALnC,IAAC,C;;;;;I,AANsB,CAAuC,G,AAAA,C;S,AAC9D,CAAC,K,AAAA,C,AAAD;;MAEe,CAAN,CAAc,G,AAAP,C,AAAP,CAAc,G,AAAD,C,AAAA;G,AAFrB,C,AAAD,IAAC,C;;;;S,AAhDP;;;;;;WASsB,SAAS,G,AAAT,CAAS,E,AAAT,EAES,KAAK,KAAK,C,AAAE,IAAI,C,AAAA,C,AAAA,E,AAC3B,GAAG,I,AAAI;;YAAa,EAAO,W,AAAA,C;M,AADvB,CAAI,G,AACqB,C,AAAE,GAAG,G,AAAA,C,AAAA,C,AAD9B,CAAI,G,AAEP,C,AAJU,E,AAAT,SAAS,G,AAAT,CAAS,E,AAoBX,GAAG,K,AAAI,EAD6B,SAAS,C,AAArC,CAAqB,KAAhB,KAAK,C,AAAE,IAAI,C,AAAA,C,AAAQ,I,AAAA,C,AACX,C,AAAE,GAAG,G,AAAA,Y,AAAA,c,AApBf,E,AAAT,SAAS,G,AAAT,CAAS,E,AAAT,IAMI,KAAK,C,AAAE,IAAI,C,AAAA,C,AAAX,mBAAW,C,AAIb,GAAG,K,AAAI,IADkB,SAAS,C,AAA1B,CAAU,KAAd,GAAC,G,AAAS,C,AAAO,I,AAAA,C,AACA,C,AAAE,GAAG,G,AAAA,c,AAAA,C,AAJb,C,AAAX,MAAW,a,AANN,E,AAAT,SAAS,G,AAAT,CAAS,E,AAAT,IAauB,KAAK,C,AAAE,IAAI,C,AAAE,E,AACnC,GAAC,M,AAAS,C,AAET,GAAG,K,AAAI,IADwB,SAAS,C,AAAhC,CAAgB,KAAX,aAAA,GAAC,C,AAAM,C,AAAO,I,AAAA,C,AACN,C,AAAE,GAAG,G,AAAA,c,AAAA,C,AADrB,C,AADT,MAAkB,a,AAGhB,C,AAjBS,E,AAAT,mBAsBU,8BAA8B,C,AAtB/B,C;;;;W,AA8BK,CAAG,G,AAAA,C;;;;W,AAIjB;;WAAK,CAAwB,KAAL,CAAC,C,AAAO,I,AAA1B,C;K,AAA0B,C;;U,AA1C5C,KAAK,K,AAAA,E,AAAL,IAGQ,CAAI,qBAAS,C,AAAA,C,AACnB,CA6BJ,YA5BI,cAFA,KAAG,G,AAEe,C,AAAA,C,AA2Bf,UAAU,C,AA1BZ,YACE;;;IAuB+C,C,AA3BlD,KAAG,G,AA2B+C,C,AACjD,C,AACY,C,AAChB,C,AAAG,GAAG,G,AAAA,C,AA7BF,E,AAJH,KAAK,K,AAAA,C,AAAL,CAoCF;;OAAA,cAAQ,WAAW,KAAC,C,AAAA,C,AAAC,C;O,AAGlB,UAAU,C,AAFZ,aACE,EAHC,KAAC,G,AAGmB,Y;;;K,AAAQ,E,AAA7B,KAA6B,C,AAAA,C,AACnB;K,AAAC,C,AAAE,qBAAS,C,AAvClB,C,AAAL,KAAK,K,AAAA,C,AAAL,CA4CC,UAAU,C,AADV,UAAU,C,AAFb,EACI;;WAAA;;;KAA0C,U;K,AAAC,E,AAD/C,KAGwB,G,AAHlB,S,AACyC,C,AAClC,C,AACA,C,AAAE,qBAAS,C,AA5CjB,C,AAAL,CACM,cAAC,cAAO,KAAK,C,AAAA,E,AAAC,C,AAAE,qBAAS,C,AAD1B,C;G,AA4CiB,C;;;;;;;U,AAnDmB,EAEpC,K,AAF4C,C,AAC5C;;OAAK,EAAC;I,AAAA,C,AACV,IAAI,C;;I,AAFf,4BAA4B,KAAK,C,AAAC,C;I,AAAI;;;UAAA,qCAGrC,C;G,AAAA,C;;;;;;;;S,AAhFD;;;;;;;;;UAIkC,GAAI,G,AAAA,C;e,AAAJ,GAAI,G,AAAA,C;W,AAAJ,GAAI,G,AAAA,C;Y,AACpB,yBAAI,E,AAAJ,OAGI,MAAS,G,AAAA,C,AAAT,SAAS,G,AAAT,CAAS,E,AAAT,EAEI,MAAO,CAAA,MAAI,C,AAAE,KAAK,C,AAAA,C,AAAC,C,AAAnB,eAAmB,E,AAGrB,CAAC,C,AAAE,IAAI,E,AAAP,CACS,G,AAAA,G,AADS,E;;S,AAAlB,CACS,G,AAAA,G,AAAA;M,AAJY,E,AAAnB,IAAmB,E,AAFvB,SAAS,G,AAAT,CAAS,E,AAAT,IA8BI,YAAY,IAAI,C,AAAC,KAAK,C,AAAA,C,AAAtB,GAAsB,M,AAAA,C,AAAtB,IAAsB,E,AAChB,CAAC,C,AAAE,IAAI,E,AAAP,GAAwB,G,AAAX,E;;S,AAAO,MAAI;M,AADR,C,AAAA,E,AA9B1B,SAAS,G,AAAT,CAAS,E,AAAT,IAQI,YAAY,IAAI,C,AAAC,KAAK,C,AAAA,C,AAAtB,mBAAsB,E,AAAtB,IAKI,MAAO,CAAA,cAAP,GAAsB,G,AAAb,E,AAAC,C,AAAE,qBAAS,C,AAAA,C,AAAC,C,AAAtB,mBAAsB,E,AAGxB,CAAC,C,AAAE,IAAI,E,AAAK;;SAAZ,GACS,G,AAAA,G,AADS;M,AAAA,E;;S,AACb,MAAI;M,AAJe,E,AAAtB,IAAsB,G,AAH5B,CAAC,C,AAAE,IAAI,E,AAAK,IAAI,E;;S,AACX,MAAI;M,AAHe,C,AAAA,E,AAR1B,SAAS,G,AAAT,CAAS,E,AAAT,IAmBI,YAAY,IAAI,C,AAAC,KAAK,C,AAAA,C,AAAtB,mBAAsB,E,AAAtB,IAKI,MAAO,CAAA,cAAP,GAAsB,G,AAAb,E,AAAC,C,AAAE,qBAAS,C,AAAA,C,AAAC,C,AAAtB,mBAAsB,E,AAGxB,CAAC,C,AAAE,IAAI,E,AAAP,GACS,G,AAAA,G,AADsB,E;;S,AAC1B,MAAI;M,AAJe,E,AAAtB,IAAsB,G,AAH5B,CAAC,C,AAAE,IAAI,E,AAAK,IAAU,E;;S,AACjB,MAAI;M,AAHe,C,AAAA,E,AAnB1B,mBAiCU,8BAA8B,C,AAjC/B,E,AAHb,IAAI,C;;M,AAHN,MAAM,C;Q,AACd,EACI,gCAAA,GAsCH,C,AAAA,E,AAvCA;;QAAK,MAAI;K,AAAA,Q,AAuCT,C;W,AACE;;QAAyB,CAAA,CAAC,C,AAAE,MAAI,C,AAAA;K,AAAE,C;;;;;W,AA0BX,mBAElB,IAFkB,GAAK,G,AAAA,C,AAEhB,CAAA,SAAI,C,AAAE,KAAK,C,AAAA,C,AAAC,C,AAAI;;gDACnB,GAAC,M,AAAM,MAAM,C,AAAW,O,AACpB,I;K,AAAC,C,AAJc,C;;Q,AArElC,CAAI,G,AAAA,C;S,AAAJ,CAAI,G,AAAA,C;U,AA4CC,KAAK,K,AAAA,C,AAET,KAA8B,G,AAFrB,M,AAAA,C,AAAL,UAEJ,KAA8B,G,AAIa,C,AAAC,IAAI,C,AAJhD,KAA8B,G,AAIuB,C,AAN5C,C,AAGD,IAAI,K,AAAA,G,AACR,IAAY,G,AAAU,G,AAF1B,KAA8B,G,AAAP,G,AAEU,G,AAAX,IAAlB,IAAY,G,AADJ,C,AACR,IAAY,G,AADJ,M,AACqB,C,AADrB,C,AAAA,C,AACyB,UAFrC,KAA8B,G,AAEqB,C,AAAC,KAAI,C,AAFxD,KAA8B,G,AAE+B,C,AAAA,C,AACpD,IAAI,C,AALT,KAAK,K,AAAA,E,AAAL,UAOJ,KAAkC,G,AAPzB,Y,AAOT,KAAkC,G,AAPzB,E,AAQP,EAAA,iCAAkC,CAAA,IAAI,C,AAAE,KAAK,C,AAAA,C,AAAC,C,AAC3C,iDACK,IAAM,cAAsB,MAAM,M,AAAA,C,AACtC;;;;QACO,CAAC,G,AAAG,MAAM,C;Y,AACT;;UAAM,CAAA,UAAU,GAAG,C,AAAA,C,AAAE,MAAI,C,AAAA;O,AAAC,C;;;S,AAEpB,UAAW,CAAA,MAAI,C,AAAE,KAAK,C,AAAA,C,AAAC,C;U,AAAvB,eAAuB,C;;oB,AAGzB,GAAG,C,AAAE,CAAC,C,AAAN,CACgB,G,AAAA,G,AADD,E;W,AACV,CAAC,C,AAAG,CAAC,C;gB,AADV,CACgB,G,AAAA,G,AAAA,C;;;e,AAJd,IAAuB,C;;K,AAKjC,CAAC,C,AAAC,IAAI,C,AAAA,I,AACb,E,AArBM,E,AAAL,KAAK,K,AAAA,E,AAAL,QAwBF,IAAA,EACI,gCAAA,CAIe,C,AAAA,E,AALlB;;OAAK,IAAI;I,AAAA,G,AAFZ,KAAW,G,AAEQ,C,AAKE,C,AAChB;;OAAyB,CAAA,GAAK,C,AAAE,MAAI,C,AAAA;I,AAAE,C,AA9BlC,E,AACT,KAAM,G,AADG,C,AACI,CAAA,IAAI,C,AAAE,KAAK,C,AAAA,C,AADf,C;G,AA8BkC,C;;;"
}
